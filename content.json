{"meta":{"title":"ncnom's blog","subtitle":null,"description":null,"author":"ncmon","url":"http://ncmon.com"},"pages":[{"title":"分类","slug":"categories","date":"2018-09-30T14:58:00.677Z","updated":"2018-09-30T14:58:00.677Z","path":"categories/index.html","link":"http://ncmon.com/categories/","permalink":"http://ncmon.com/categories/index.html","excerpt":"","text":""},{"title":"","slug":"about","date":"2018-11-03T05:07:43.877Z","updated":"2018-11-03T05:07:43.877Z","path":"about/index.html","link":"http://ncmon.com/about/","permalink":"http://ncmon.com/about/index.html","excerpt":"","text":"关于我ncmon 幸运的生活在互联网时代的Android程序猿，正在Android学习的路上不断摸索； 遇到有意思的学习案例也希望能在此分享。 建站初衷也许说记录学习笔记更贴近一些实际，当然在这个行业待得时间越久越会觉得开源技术、分享过程的人对新人来说是多么重要，虽然也是个新人，把自己的学习路程分享出来既对所得知识进行一次巩固，也希望能帮助需要的人让分享成为一种乐趣。 光影业余时间也会练习一些摄影，自我感觉良好的照片和看到喜欢的照片会记录一份在这里p(#￣▽￣#)o 联系我Email: ncmonlx@outlook.comLocation: 中国北京"}],"posts":[{"title":"Android Jetpack Architecture之ViewModel","slug":"Jetpack-Architecture-ViewModel","date":"2018-09-26T12:40:11.000Z","updated":"2018-10-27T06:02:35.102Z","path":"post/Jetpack-Architecture-ViewModel/","link":"http://ncmon.com/post/Jetpack-Architecture-ViewModel/","permalink":"http://ncmon.com/post/Jetpack-Architecture-ViewModel/","excerpt":"前言&ensp;&ensp;Jetpack已经出了很久很久了，近几年的GDD几乎每次都会介绍新的组件，说来惭愧，一直没有好好学习，看近年的Google 的很多Demo中其实都有所体现，之前都是大概的了解了一遍。最近决定，好好梳理一遍，既学习其用法，也尝试学习下其设计思想。也是时候该补充一下了。进入正题–ViewModel&ensp;&ensp;首先都是看官方的例子，ViewModel官方的的例子是会和另一个架构库LiveData写在一起，很多的博客也是照官方的例子来说明，开始接触时甚至给了我一种假象：ViewModel都是和LiveData一起使用的。后来阅读才了解，ViewModel和LiveData职责分工还是很明显的，使用LiveData Demo主要使用其observe功能，LiveDate的使用及原理之后再分析，甚至在appcompat-v7:27.1.1中直接单独集成了ViewModel.所以，故为排除干扰，今天不会使用官方的主流Demo用法，先来看ViewModel。","text":"前言&ensp;&ensp;Jetpack已经出了很久很久了，近几年的GDD几乎每次都会介绍新的组件，说来惭愧，一直没有好好学习，看近年的Google 的很多Demo中其实都有所体现，之前都是大概的了解了一遍。最近决定，好好梳理一遍，既学习其用法，也尝试学习下其设计思想。也是时候该补充一下了。进入正题–ViewModel&ensp;&ensp;首先都是看官方的例子，ViewModel官方的的例子是会和另一个架构库LiveData写在一起，很多的博客也是照官方的例子来说明，开始接触时甚至给了我一种假象：ViewModel都是和LiveData一起使用的。后来阅读才了解，ViewModel和LiveData职责分工还是很明显的，使用LiveData Demo主要使用其observe功能，LiveDate的使用及原理之后再分析，甚至在appcompat-v7:27.1.1中直接单独集成了ViewModel.所以，故为排除干扰，今天不会使用官方的主流Demo用法，先来看ViewModel。 ViewModel简介&ensp;&ensp;Android的UI控制器（Activity和Fragment）从创建到销毁拥有自己完整的生命周期，当系统配置发生改变时（(Configuration changes)），系统就会销毁Activity和与之关联的Fragment然后再次重建（可通过在AndroidManifast.xml中配置android:configChanges修改某些行为，这里不讨论）,那么存储在当前UI中的临时数据也会被清空，例如，登陆输入框，输入账号或密码后旋转屏幕，视图被重建，输入过的数据也清空了，这无疑是一种不友好的用户体验。对于少量的可序列化数据可以使用onSaveInstanceState()方法保存然后在onCreate()方法中重新恢复，正如所说onSaveInstanceState对于大量的数据缓存有一定的局限性，大量的数据缓存则可以使用Fragment.setRetainInstance(true)来保存数据。ViewModel也是提供了相同的功能，用来存储和管理与UI相关的数据，允许数据在系统配置变化后存活，我们一起看一下这个ViewModel的缓存是怎么实现的呢？ ViewModel使用方式先上效果图1234567891011121314public class MyViewModel extends ViewModel &#123; String name; public String getName()&#123; return name; &#125; public void setName(String name)&#123; this.name = name; &#125; @Override protected void onCleared() &#123; super.onCleared(); name = null; &#125; &#125; &nbsp;1234567891011121314151617181920212223242526272829303132public class ViewModelActivity extends AppCompatActivity implements View.OnClickListener &#123; private static final String TAG = \"ViewModelActivity\"; TextView textView; private MyViewModel myViewModel; @Override protected void onCreate(@Nullable Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_viewmodel); textView = findViewById(R.id.textView); textView.setOnClickListener(this); ViewModelProvider.Factory factory = ViewModelProvider.AndroidViewModelFactory.getInstance(getApplication()); /* *这里的this是ViewModelStoreOwner接口在appcompat-v7:27.1.1支持库中AppCompatActivity已经实现了， *如果是较低版本，需要更新支持包或者参考其实现对本来继承的Activity做对应实现。 */ ViewModelProvider provider = new ViewModelProvider(this, factory);// myViewModel = provider.get(MyViewModel.class); Log.e(TAG, \"onCreate: \" + myViewModel.getName() ); if (myViewModel.getName() != null) &#123; textView.setText(myViewModel.getName()); &#125; &#125; @Override public void onClick(View v) &#123; switch (v.getId())&#123; case R.id.textView: myViewModel.setName(\"MyViewModel Test\"); textView.setText(myViewModel.getName()); break; &#125; &#125;&#125; &nbsp;123456789101112131415161718192021222324&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;android.support.constraint.ConstraintLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:app=\"http://schemas.android.com/apk/res-auto\" xmlns:tools=\"http://schemas.android.com/tools\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\"&gt; &lt;TextView android:id=\"@+id/textView\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:layout_marginStart=\"8dp\" android:layout_marginTop=\"8dp\" android:layout_marginEnd=\"8dp\" android:layout_marginBottom=\"8dp\" android:text=\"default\" app:layout_constraintBottom_toBottomOf=\"parent\" app:layout_constraintEnd_toEndOf=\"parent\" app:layout_constraintStart_toStartOf=\"parent\" app:layout_constraintTop_toTopOf=\"parent\" /&gt;&lt;/android.support.constraint.ConstraintLayout&gt; 非常简单的一个例子，这就是ViewModel最简单的使用了，就是TextView中显示ViewModel的数据。ViewModel需要由ViewModelProvider.get(Class)来取得，旋转屏幕销毁后，之前改变的数据还在。接下来就是进入主题分析下ViewModel到底是怎么实现的呢？带着问题看源码： 带给我们的疑问 ViewModelProvider是干啥的？ AndroidViewModelFactory 这命名一看就是应该是工厂模式，工厂创建了什么？ provider.get(MyViewModel.class) 这里直接使用的get命名就得到了需要的唯一数据 注释中ViewModelStoreOwner又是什么角色？先看ViewModel类，没什么说的，就是一个么有任何真正实现的抽象类，只有一个抽象方法onCleared() 原理分析1234567891011public abstract class ViewModel &#123; /** * This method will be called when this ViewModel is no longer used and will be destroyed. * &lt;p&gt; * It is useful when ViewModel observes some data and you need to clear this subscription to * prevent a leak of this ViewModel. */ @SuppressWarnings(\"WeakerAccess\") protected void onCleared() &#123; &#125;&#125; 接着看下ViewModelFactory，顾名思义就是制造ViewModel的。AndroidViewModelFactory的继承关系如下: android.arch.lifecycle.ViewModelProvider.Factory android.arch.lifecycle.ViewModelProvider.NewInstanceFactory android.arch.lifecycle.ViewModelProvider.AndroidViewModelFactory Factory是一个只包含一个create的interface，NewInstanceFactory实现了该方法传入Class会利用ViewModel的默认无参构造器创建一个对应ViewModel的实例，而AndroidViewModelFactory增加了一个属性就是应用的Applicaion,同时重写create方法，查看ViewModel是否有包含Applicaion参数的构造方法从而使用，对应的其实还有一个AndroidViewModel是ViewModel的子类，默认已经实现了带有Application参数的构造方法，需要使用在ViewModel中使用application的直接继承AndroidViewModel就可以，看到这里其实最上面的例子有个不是问题的问题，其实上面的Factory直接使用NewInstanceFactory就可以创建出对应的ViewModel实例了。123456789101112131415/** * Implementations of &#123;@code Factory&#125; interface are responsible to instantiate ViewModels. */public interface Factory &#123; /** * Creates a new instance of the given &#123;@code Class&#125;. * &lt;p&gt; * * @param modelClass a &#123;@code Class&#125; whose instance is requested * @param &lt;T&gt; The type parameter for the ViewModel. * @return a newly created ViewModel */ @NonNull &lt;T extends ViewModel&gt; T create(@NonNull Class&lt;T&gt; modelClass);&#125; 12345678910111213141516171819/** * Simple factory, which calls empty constructor on the give class. */public static class NewInstanceFactory implements Factory &#123; @SuppressWarnings(\"ClassNewInstance\") @NonNull @Override public &lt;T extends ViewModel&gt; T create(@NonNull Class&lt;T&gt; modelClass) &#123; //noinspection TryWithIdenticalCatches try &#123; return modelClass.newInstance(); &#125; catch (InstantiationException e) &#123; throw new RuntimeException(\"Cannot create an instance of \" + modelClass, e); &#125; catch (IllegalAccessException e) &#123; throw new RuntimeException(\"Cannot create an instance of \" + modelClass, e); &#125; &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253/** * &#123;@link Factory&#125; which may create &#123;@link AndroidViewModel&#125; and * &#123;@link ViewModel&#125;, which have an empty constructor. */public static class AndroidViewModelFactory extends ViewModelProvider.NewInstanceFactory &#123; private static AndroidViewModelFactory sInstance; /** * Retrieve a singleton instance of AndroidViewModelFactory. * * @param application an application to pass in &#123;@link AndroidViewModel&#125; * @return A valid &#123;@link AndroidViewModelFactory&#125; */ @NonNull public static AndroidViewModelFactory getInstance(@NonNull Application application) &#123; if (sInstance == null) &#123; sInstance = new AndroidViewModelFactory(application); &#125; return sInstance; &#125; private Application mApplication; /** * Creates a &#123;@code AndroidViewModelFactory&#125; * * @param application an application to pass in &#123;@link AndroidViewModel&#125; */ public AndroidViewModelFactory(@NonNull Application application) &#123; mApplication = application; &#125; @NonNull @Override public &lt;T extends ViewModel&gt; T create(@NonNull Class&lt;T&gt; modelClass) &#123; if (AndroidViewModel.class.isAssignableFrom(modelClass)) &#123; //noinspection TryWithIdenticalCatches try &#123; return modelClass.getConstructor(Application.class).newInstance(mApplication); &#125; catch (NoSuchMethodException e) &#123; throw new RuntimeException(\"Cannot create an instance of \" + modelClass, e); &#125; catch (IllegalAccessException e) &#123; throw new RuntimeException(\"Cannot create an instance of \" + modelClass, e); &#125; catch (InstantiationException e) &#123; throw new RuntimeException(\"Cannot create an instance of \" + modelClass, e); &#125; catch (InvocationTargetException e) &#123; throw new RuntimeException(\"Cannot create an instance of \" + modelClass, e); &#125; &#125; return super.create(modelClass); &#125;&#125; 之后通过ViewModelStoreOwner和刚刚创建的Factory创建出ViewModelPrivider实例12345678910111213141516171819202122232425/** * Creates &#123;@code ViewModelProvider&#125;, which will create &#123;@code ViewModels&#125; via the given * &#123;@code Factory&#125; and retain them in a store of the given &#123;@code ViewModelStoreOwner&#125;. * * @param owner a &#123;@code ViewModelStoreOwner&#125; whose &#123;@link ViewModelStore&#125; will be used to * retain &#123;@code ViewModels&#125; * @param factory a &#123;@code Factory&#125; which will be used to instantiate * new &#123;@code ViewModels&#125; */public ViewModelProvider(@NonNull ViewModelStoreOwner owner, @NonNull Factory factory) &#123; this(owner.getViewModelStore(), factory);&#125;/** * Creates &#123;@code ViewModelProvider&#125;, which will create &#123;@code ViewModels&#125; via the given * &#123;@code Factory&#125; and retain them in the given &#123;@code store&#125;. * * @param store &#123;@code ViewModelStore&#125; where ViewModels will be stored. * @param factory factory a &#123;@code Factory&#125; which will be used to instantiate * new &#123;@code ViewModels&#125; */public ViewModelProvider(@NonNull ViewModelStore store, @NonNull Factory factory) &#123; mFactory = factory; this.mViewModelStore = store;&#125; 1234567891011121314151617/** * A scope that owns &#123;@link ViewModelStore&#125;. * &lt;p&gt; * A responsibility of an implementation of this interface is to retain owned ViewModelStore * during the configuration changes and call &#123;@link ViewModelStore#clear()&#125;, when this scope is * going to be destroyed. */@SuppressWarnings(\"WeakerAccess\")public interface ViewModelStoreOwner &#123; /** * Returns owned &#123;@link ViewModelStore&#125; * * @return a &#123;@code ViewModelStore&#125; */ @NonNull ViewModelStore getViewModelStore();&#125; ViewModelStoreOwner 也是一个接口是FragmentActivity实现了该接口并实现了其中的getViewModelStore()方法1234567891011121314151617181920212223242526272829303132public class FragmentActivity extends BaseFragmentActivityApi16 implements ViewModelStoreOwner...&#123; private ViewModelStore mViewModelStore; @Override protected void onCreate(@Nullable Bundle savedInstanceState) &#123; mFragments.attachHost(null /*parent*/); super.onCreate(savedInstanceState); NonConfigurationInstances nc = (NonConfigurationInstances) getLastNonConfigurationInstance(); if (nc != null) &#123; mViewModelStore = nc.viewModelStore; &#125; /** * Returns the &#123;@link ViewModelStore&#125; associated with this activity * * @return a &#123;@code ViewModelStore&#125; */ @NonNull @Override public ViewModelStore getViewModelStore() &#123; if (getApplication() == null) &#123; throw new IllegalStateException(\"Your activity is not yet attached to the \" + \"Application instance. You can't request ViewModel before onCreate call.\"); &#125; if (mViewModelStore == null) &#123; mViewModelStore = new ViewModelStore(); &#125; return mViewModelStore; &#125;&#125; 这个ViewModelStore又是什么呢，其实就是真正利用HashMap存储ViewModel的地方了，看下代码在存储和clear同时会调用ViewModel需要实现的抽象方法onClear()12345678910111213141516171819202122232425public class ViewModelStore &#123; private final HashMap&lt;String, ViewModel&gt; mMap = new HashMap&lt;&gt;(); final void put(String key, ViewModel viewModel) &#123; ViewModel oldViewModel = mMap.put(key, viewModel); if (oldViewModel != null) &#123; oldViewModel.onCleared(); &#125; &#125; final ViewModel get(String key) &#123; return mMap.get(key); &#125; /** * Clears internal storage and notifies ViewModels that they are no longer used. */ public final void clear() &#123; for (ViewModel vm : mMap.values()) &#123; vm.onCleared(); &#125; mMap.clear(); &#125;&#125; 这样ViewModelProvider就是有了一个ViewModel的容器，这时去调用ViewModelProvider的get(Class)方法就是去调用mViewModelStore的get()方法取出对应的ViewModel所以这里只要持有的ViewModelStore是有缓存的，那么取出的ViewModel就是相同的缓存了。12345678910111213141516171819202122232425262728293031323334353637383940414243/** * Returns an existing ViewModel or creates a new one in the scope (usually, a fragment or * an activity), associated with this &#123;@code ViewModelProvider&#125;. * &lt;p&gt; * The created ViewModel is associated with the given scope and will be retained * as long as the scope is alive (e.g. if it is an activity, until it is * finished or process is killed). * * @param modelClass The class of the ViewModel to create an instance of it if it is not * present. * @param &lt;T&gt; The type parameter for the ViewModel. * @return A ViewModel that is an instance of the given type &#123;@code T&#125;. */@NonNull@MainThreadpublic &lt;T extends ViewModel&gt; T get(@NonNull Class&lt;T&gt; modelClass) &#123; String canonicalName = modelClass.getCanonicalName(); if (canonicalName == null) &#123; throw new IllegalArgumentException(\"Local and anonymous classes can not be ViewModels\"); &#125; return get(DEFAULT_KEY + \":\" + canonicalName, modelClass);&#125;@NonNull@MainThreadpublic &lt;T extends ViewModel&gt; T get(@NonNull String key, @NonNull Class&lt;T&gt; modelClass) &#123; ViewModel viewModel = mViewModelStore.get(key); if (modelClass.isInstance(viewModel)) &#123; //noinspection unchecked return (T) viewModel; &#125; else &#123; //noinspection StatementWithEmptyBody if (viewModel != null) &#123; // TODO: log a warning. &#125; &#125; viewModel = mFactory.create(modelClass); mViewModelStore.put(key, viewModel); //noinspection unchecked return (T) viewModel;&#125; 看到这里就会发现ViewModelStore的缓存其实是通过NonConfigurationInstances的缓存来实现的，这样就完成了Activity销毁重建后ViewModel还保存原来的数据的过程，那么NonConfigurationInstances 是什么呢？如果有了解过使用在Activity中使用onRetainNonConfigurationInstance()保存缓存数据，在onCreate()中通过getLastNonConfigurationInstance()恢复之前的数据状态的同学可能会很熟悉这里的写法，是的，这里FragmentActivity就是使用的这种方式来保存之前的ViewModelStore,看下FragmentActivity的onRetainNonConfigurationInstance()方法。 12345678910111213141516171819202122232425/** * Retain all appropriate fragment state. You can NOT * override this yourself! Use &#123;@link #onRetainCustomNonConfigurationInstance()&#125; * if you want to retain your own state. */@Overridepublic final Object onRetainNonConfigurationInstance() &#123; if (mStopped) &#123; doReallyStop(true); &#125; Object custom = onRetainCustomNonConfigurationInstance(); FragmentManagerNonConfig fragments = mFragments.retainNestedNonConfig(); if (fragments == null &amp;&amp; mViewModelStore == null &amp;&amp; custom == null) &#123; return null; &#125; NonConfigurationInstances nci = new NonConfigurationInstances(); nci.custom = custom; nci.viewModelStore = mViewModelStore;//就是这里了，会把之前的VeiwmodelStroe存储到NonConfigurationInstances中以供后续恢复使用 nci.fragments = fragments; return nci;&#125; 这里其实再次出现了一个问题 onRetainNonConfigurationInstance()和getLastNonConfigurationInstance()又是怎么恢复数据呢?…这个其实和Activity的启动流程相关，这里也介绍一下吧，之后的内容其实是Activity的内容了，趁这次看ViwModel也跟着看了一遍，有了解过Activity启动流程的同学更容易理解的多，大家酌情观看。 也不能从头开始说起，再从头就要越扯越远了，就从ActivityThread.java中的scheduleLaunchActivity开始1234567891011121314151617181920212223242526272829303132333435@Overridepublic final void scheduleLaunchActivity(Intent intent, IBinder token, int ident, ActivityInfo info, Configuration curConfig, Configuration overrideConfig, CompatibilityInfo compatInfo, String referrer, IVoiceInteractor voiceInteractor, int procState, Bundle state, PersistableBundle persistentState, List&lt;ResultInfo&gt; pendingResults, List&lt;ReferrerIntent&gt; pendingNewIntents, boolean notResumed, boolean isForward, ProfilerInfo profilerInfo) &#123; updateProcessState(procState, false); ActivityClientRecord r = new ActivityClientRecord(); r.token = token; r.ident = ident; r.intent = intent; r.referrer = referrer; r.voiceInteractor = voiceInteractor; r.activityInfo = info; r.compatInfo = compatInfo; r.state = state; r.persistentState = persistentState; r.pendingResults = pendingResults; r.pendingIntents = pendingNewIntents; r.startsNotResumed = notResumed; r.isForward = isForward; r.profilerInfo = profilerInfo; r.overrideConfig = overrideConfig; updatePendingConfiguration(curConfig); sendMessage(H.LAUNCH_ACTIVITY, r);&#125; 从ActivityThread.java中H（extents Handler）接收到LAUNCH_ACTIVITY，并且会接收ActivityClientRecord，其中会调用ActivityThread的handleLaunchActivity方法：1234567891011121314//ActivityThread.java//没有前后文的H中的handleMessage~~~ public void handleMessage(Message msg) &#123; if (DEBUG_MESSAGES) Slog.v(TAG, \"&gt;&gt;&gt; handling: \" + codeToString(msg.what)); switch (msg.what) &#123; case LAUNCH_ACTIVITY: &#123; Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, \"activityStart\"); final ActivityClientRecord r = (ActivityClientRecord) msg.obj; //ActivityClientRecord 是apk进程中一个Activity的代表，这个对象的activity成员引用真正的Activity组件,后面的都和它有关系 r.packageInfo = getPackageInfoNoCheck( r.activityInfo.applicationInfo, r.compatInfo); handleLaunchActivity(r, null, \"LAUNCH_ACTIVITY\");///这里~这里~ Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER); &#125; break; 1234567891011121314151617181920212223242526272829private void handleLaunchActivity(ActivityClientRecord r, Intent customIntent, String reason) &#123; ... Activity a = performLaunchActivity(r, customIntent); ...&#125;private Activity performLaunchActivity(ActivityClientRecord r, Intent customIntent) &#123;... if (activity != null) &#123; CharSequence title = r.activityInfo.loadLabel(appContext.getPackageManager()); Configuration config = new Configuration(mCompatConfiguration); if (r.overrideConfig != null) &#123; config.updateFrom(r.overrideConfig); &#125; if (DEBUG_CONFIGURATION) Slog.v(TAG, \"Launching activity \" + r.activityInfo.name + \" with config \" + config); Window window = null; if (r.mPendingRemoveWindow != null &amp;&amp; r.mPreserveWindow) &#123; window = r.mPendingRemoveWindow; r.mPendingRemoveWindow = null; r.mPendingRemoveWindowManager = null; &#125; appContext.setOuterContext(activity); activity.attach(appContext, this, getInstrumentation(), r.token, r.ident, app, r.intent, r.activityInfo, title, r.parent, r.embeddedID, r.lastNonConfigurationInstances, config, //看到这个r.lastNonConfigurationInstances 就是在Activity方法中调用getLastNonConfigurationInstance()获取到的Object了。 r.referrer, r.voiceInteractor, window, r.configCallback);...&#125; 注释中的地方就是lastNonConfigurationInstances的赋值的地方，可能会发现在scheduleLaunchActivity并没有对lastNonConfigurationInstances赋值，因为第一次启动Activity时，这里其实就是null的，那么赋值的地方在哪里呢，既然是销毁后会恢复数据，追踪发现在performDestroyActivity()也就是在调用onDestroy生命周期之前有这样一段代码1234567891011121314151617181920212223private ActivityClientRecord performDestroyActivity(IBinder token, boolean finishing, int configChanges, boolean getNonConfigInstance) &#123; ActivityClientRecord r = mActivities.get(token); ...无关代码省略 if (getNonConfigInstance) &#123; try &#123; r.lastNonConfigurationInstances = r.activity.retainNonConfigurationInstances();///就是这里出现了想要找的NonConfigurationInstances &#125; catch (Exception e) &#123; if (!mInstrumentation.onException(r.activity, e)) &#123; throw new RuntimeException( \"Unable to retain activity \" + r.intent.getComponent().toShortString() + \": \" + e.toString(), e); &#125; &#125; &#125; try &#123; r.activity.mCalled = false; mInstrumentation.callActivityOnDestroy(r.activity); ...无关代码省略 return r; &#125; 在performDestroyActivity()调用了Activity.retainNonConfigurationInstances()方法了，所以逻辑切换回Activity中…1234567891011121314151617181920212223242526272829303132333435363738394041 /** * This method is similar to &#123;@link #onRetainNonConfigurationInstance()&#125; except that * it should return either a mapping from child activity id strings to arbitrary objects, * or null. This method is intended to be used by Activity framework subclasses that control a * set of child activities, such as ActivityGroup. The same guarantees and restrictions apply * as for &#123;@link #onRetainNonConfigurationInstance()&#125;. The default implementation returns null. */@NullableHashMap&lt;String,Object&gt; onRetainNonConfigurationChildInstances() &#123; return null;&#125;NonConfigurationInstances retainNonConfigurationInstances() &#123; Object activity = onRetainNonConfigurationInstance();///熟悉的代码，原来的配方，和分析ActivityThread之前联系起来了，在Activity中是空实现，这里就是获取子类的NonConfigurationInstance()，之前的例子就是的得FragmentActivity中的具体实现，上文中已经在分析ActivityThread.java已经指出。 HashMap&lt;String, Object&gt; children = onRetainNonConfigurationChildInstances(); FragmentManagerNonConfig fragments = mFragments.retainNestedNonConfig(); // We're already stopped but we've been asked to retain. // Our fragments are taken care of but we need to mark the loaders for retention. // In order to do this correctly we need to restart the loaders first before // handing them off to the next activity. mFragments.doLoaderStart(); mFragments.doLoaderStop(true); ArrayMap&lt;String, LoaderManager&gt; loaders = mFragments.retainLoaderNonConfig(); if (activity == null &amp;&amp; children == null &amp;&amp; fragments == null &amp;&amp; loaders == null &amp;&amp; mVoiceInteractor == null) &#123; return null; &#125; NonConfigurationInstances nci = new NonConfigurationInstances(); nci.activity = activity; nci.children = children; nci.fragments = fragments; nci.loaders = loaders; if (mVoiceInteractor != null) &#123; mVoiceInteractor.retainInstance(); nci.voiceInteractor = mVoiceInteractor; &#125; return nci;//这里返回的是Activity中的NonConfigurationInstances就保存在了ActivityClientRecord中了&#125; 至此，ActivityClientRecord就不再深入了，可以看到在Activity中是以一个ArrayMap来保存Activity的记录，记录的就是Activity的状态，所以这里就实现了对NonConfigurationInstances的保存。 结语：至此就基本看完了ViewModel在Activity中的使用和原理，在Fragment中的实现主要是使用setRetainInstance(true)的方式去保存，跟今天的分析也有关联，分析源码的过程总是看着就有新的问题，再次带着问题去解决会再次有不同的收获，本文的理解也可能有偏差，如有错误和想要交流的也欢迎指正沟通。","categories":[{"name":"技术栈","slug":"技术栈","permalink":"http://ncmon.com/categories/技术栈/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://ncmon.com/tags/Android/"},{"name":"Jetpack","slug":"Jetpack","permalink":"http://ncmon.com/tags/Jetpack/"}]},{"title":"Ubuntu搭建Nginx图片服务器","slug":"build-an-image-server","date":"2018-01-11T12:40:11.000Z","updated":"2018-10-26T14:54:02.067Z","path":"post/build-an-image-server/","link":"http://ncmon.com/post/build-an-image-server/","permalink":"http://ncmon.com/post/build-an-image-server/","excerpt":"也许算作是建站以来的第一篇真正意义上的总结博客。 首先感谢开源本主题的viosey同学和辛苦维护本主题的neoFelhz同学，对此主题极为喜欢。 新发现了当前的这个Meterial主题后发现居然有一个Gallery模板可以展示照片，平时的博客使用图片需要存放在一个位置上，平时也有一些业余的摄影爱好需要刚好可以存放，当然可以使用如之前使用过的七牛云等云对象存储平台存储使用，我这里也是刚好有个云服务器可以做存储就想着自己搭建一个图片服务器方便管理，也刚好能学习一下服务器方面的一些知识，经多次尝试，故总结一下,话不多说，开始行动.","text":"也许算作是建站以来的第一篇真正意义上的总结博客。 首先感谢开源本主题的viosey同学和辛苦维护本主题的neoFelhz同学，对此主题极为喜欢。 新发现了当前的这个Meterial主题后发现居然有一个Gallery模板可以展示照片，平时的博客使用图片需要存放在一个位置上，平时也有一些业余的摄影爱好需要刚好可以存放，当然可以使用如之前使用过的七牛云等云对象存储平台存储使用，我这里也是刚好有个云服务器可以做存储就想着自己搭建一个图片服务器方便管理，也刚好能学习一下服务器方面的一些知识，经多次尝试，故总结一下,话不多说，开始行动. 环境准备Ubuntu版本Ubuntu 16.04.3 安装Nginx首先是准备编译Nginx的前期准备工作 先更新一下源&gt; apt-get update 安装gcc g++依赖库&gt; apt-get install build-essential &gt; apt-get install libtool 安装prce依赖库&gt; apt-get install libpcre3 libpcre3-dev 安装 zlib依赖库&gt; apt-get install zlib1g-dev 安装 ssl依赖库&gt; apt-get install openssl 编译Nginx下载Nginx有对应的版本，我这里下载是当前的最新版本1.13.8 &gt; #解压下载下来的压缩包 &gt; tar -zxvf nginx-1.13.8.tar.gz &gt; #进入解压目录 &gt; cd nginx-1.13.8 &gt; #配置并生成makefile &gt; ./configure --prefix=/usr/local/nginx &gt; #编译 &gt; make &gt; #安装 &gt; make install &gt; #启动Nginx &gt; /usr/local/nginx/sbin/nginx -c /usr/local/nginx/conf/nginx.conf 此时Nginx就安装完成了，会使用默认的80端口启动，如果有启动apache2服务的这里会用冲突，这里不是重点，可查询解决，启动完成可直接通过服务器ip或者云解析的域名查看默认网页 默认的网页长这个样子 安装与配置vsftpd安装vsftpd&gt; apt-get install vsftpd 启动vsftpd服务&gt;service vsftpd start 新建ftpuser目录作为ftp主目录 （ftpuser为目录名，随个人喜好创建）&gt;mkdir /home/ftpuser 新建ftpuser用户指定用户主目录和设置用户密码 （ftpuser为用户名，随个人喜好创建）&gt;useradd -d /home/ftpuser -s /bin/bash ftpuser &gt;passwd ftpuser 制定用户组&gt;chown ftpuser:ftpuser /home/ftpuser 新建文件/etc/vsftpd.user_list，用于存放允许访问ftp的用户&gt;vim /etc/vsftpd.user_list 编辑vsftpd配置文件&gt;vim /etc/vsftpd.conf 做如下修改： 打开注释 write_enable=YES 添加信息 userlist_file=/etc/vsftpd.user_list 添加信息 userlist_enable=YES 添加信息 userlist_deny=NO 修改完成后保存退出。 重启vsftpd服务&gt;service vsftpd restart 这是可以使用filezilla等ftp软件使用刚刚新建的用户名和密码访问测试是否成功 OK，准备工作完成开始上传图片，开始正式图片服务器工作 创建存储图片的根目录 （在ftpuser目录下,我这里使用www/images）&gt;cd /home/ftpuser &gt;mkdir -p www/images 在nginx目录下创建images目录&gt;mkdir /usr/local/nginx/html/images 修改nginx/conf/nginx.conf在默认的server里再添加一个location并指定实际路径:location /images/ { root /home/ftpuser/www/; autoindex on; } 修改用户访问权限&gt;chmod 755 /home/ftpuser/www/images 使用filezilla 等ftp工具使用ftpuser用户登录即可上传图片 测试送上一张最近的长安街慢门效果照片★,°:.☆(￣▽￣)/$:.°★。大功告成！ 撒花！","categories":[{"name":"技术栈","slug":"技术栈","permalink":"http://ncmon.com/categories/技术栈/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://ncmon.com/tags/Linux/"},{"name":"Ubuntu","slug":"Ubuntu","permalink":"http://ncmon.com/tags/Ubuntu/"},{"name":"FTP","slug":"FTP","permalink":"http://ncmon.com/tags/FTP/"}]},{"title":"Android Studio import project 出现Error错误 程序包org.apache.http不存在","slug":"Android-Studio-Error-2","date":"2018-01-07T15:01:52.000Z","updated":"2018-10-26T14:53:31.743Z","path":"post/Android-Studio-Error-2/","link":"http://ncmon.com/post/Android-Studio-Error-2/","permalink":"http://ncmon.com/post/Android-Studio-Error-2/","excerpt":"","text":"遇到新的产品形态、样式需求我们经常会在Github搜索开源项目，有些项目是早期Android版本中开发而成，后续Google会有部分API在新版本中的SDK放弃集成，这次我导入一个项目时就遇到这样一个错误 如果经历过Android 4.4 时期的同学应该会觉得org.apache.http这个包很熟悉，这里显示错误是因为在targetsdk：23以上版本SDK中已经不再集成此包，如需使用可添加useLibrary “org.apache.http.legacy”依赖即可 。 apply plugin: &apos;com.android.application&apos; android { compileSdkVersion 23 buildToolsVersion &quot;23.0.3&quot; useLibrary &quot;org.apache.http.legacy&quot; ... }","categories":[{"name":"错误志","slug":"错误志","permalink":"http://ncmon.com/categories/错误志/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://ncmon.com/tags/Android/"},{"name":"IDEError","slug":"IDEError","permalink":"http://ncmon.com/tags/IDEError/"}]},{"title":"RecyclerView排雷--notifyItemRemoved下标（position）不能更新","slug":"RecyclerView-clear-of-mines-1","date":"2017-10-29T15:48:52.000Z","updated":"2018-01-07T15:35:18.958Z","path":"post/RecyclerView-clear-of-mines-1/","link":"http://ncmon.com/post/RecyclerView-clear-of-mines-1/","permalink":"http://ncmon.com/post/RecyclerView-clear-of-mines-1/","excerpt":"","text":"用以显示列表类型的UI我们经常使用ListView，GridView，Google推出RecyclerView之后，大部分的使用均转换到了RecyclerView中，可定制化十分强，但是使用过程中难免碰到一些问题，之前使用ListView多是使用notifyDataSetChanged（）更新数据，使用RecyclerView删除时，为了使用其自身的删除过度动画使用notifyItemRemoved删除，那么就碰到了一个问题，再onBindViewHolder中设置了setTag（position） @Override public void onBindViewHolder(RecyclerView.ViewHolder holder,int position){ //... holder.itemView.setTag(position) //... } 直接使用notifyItemRemoved(posiaon)删除会导致该下标不能更新就导致一系列的Bug（/衰）查询到了解决办法特此记录一下:为了修复该问题删除之后需要调用notifyItenRangeChanged方法，使下面的itemview重新onBind: public void deleteItem(int position){ mDataList.remove(position); notifyItemRemoved(position); if(position != mDataList.size()){ // 如果移除的是最后一个，忽略 notifyItemRangeChanged(position, mDataList.size() - position); } } 如果不需要使用动画或更改自定义的动画效果可以添加一下代码 mRecyclerView.setItemAnimator(newDefaultItemAnimator());","categories":[{"name":"技术栈","slug":"技术栈","permalink":"http://ncmon.com/categories/技术栈/"}],"tags":[]},{"title":"Android Studio 更新后出现Error:No service of type Factory  available in ProjectScopeServices.解决办法","slug":"Android-Studio-Error-1","date":"2017-03-15T17:01:52.000Z","updated":"2018-10-26T14:53:16.357Z","path":"post/Android-Studio-Error-1/","link":"http://ncmon.com/post/Android-Studio-Error-1/","permalink":"http://ncmon.com/post/Android-Studio-Error-1/","excerpt":"","text":"今天更新Android Studio后 之前能运行的项目出现错误: 查找到解决方案在此记录是github的 自动化打包插件maven 版本需要更新导致","categories":[{"name":"错误志","slug":"错误志","permalink":"http://ncmon.com/categories/错误志/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://ncmon.com/tags/Android/"},{"name":"IDEError","slug":"IDEError","permalink":"http://ncmon.com/tags/IDEError/"}]}]}