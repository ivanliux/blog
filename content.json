{"meta":{"title":"ncnom's blog","subtitle":null,"description":null,"author":"ncmon","url":"http://ncmon.com"},"pages":[{"title":"","slug":"about","date":"2019-03-02T15:29:06.768Z","updated":"2019-03-02T15:29:06.768Z","comments":true,"path":"about/index.html","link":"http://ncmon.com/about/","permalink":"http://ncmon.com/about/index.html","excerpt":"","text":"关于我ncmon 幸运的生活在互联网时代的Android程序猿，正在Android学习的路上不断摸索； 遇到有意思的学习案例也希望能在此分享。 建站初衷也许说记录学习笔记更贴近一些实际，当然在这个行业待得时间越久越会觉得开源技术、分享过程的人对新人来说是多么重要，虽然也是个新人，把自己的学习路程分享出来既对所得知识进行一次巩固，也希望能帮助需要的人让分享成为一种乐趣。 联系我Email: ncmonlx@outlook.comLocation: 中国北京"},{"title":"分类","slug":"categories","date":"2018-09-30T14:58:00.677Z","updated":"2018-09-30T14:58:00.677Z","comments":true,"path":"categories/index.html","link":"http://ncmon.com/categories/","permalink":"http://ncmon.com/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"关于getDeviceId和getImei获取值不同的分析","slug":"android-get-imei","date":"2020-03-22T13:29:09.000Z","updated":"2020-03-22T13:39:14.338Z","comments":true,"path":"post/android-get-imei/","link":"http://ncmon.com/post/android-get-imei/","permalink":"http://ncmon.com/post/android-get-imei/","excerpt":"问题背景需要获取imei的值，很容易查询到使用TelephonyManager的getDeviceId()（在API Level 26 以上已标记为@Deprecated，在很多Android 26以上设备上也可继续使用）方法和getImei()方法（注释标记该方法需在API Level 26 以上调用，不过实测在有些26以下设备也可以调用到）Tips:Android Q 以上获取imei的需要READ_PRIVILEGED_PHONE_STATE 权限，该权限只有系统应用可以获取，普通应用使用以上两种方法获取均会抛出异常SecurityException，不过本文这不是重点，所以本文指的是Android Q以下相关设备。网上的说法这两个都是获取imei的方法，是使用的API Level不同，所以使用时一直以为如果遇到两个方法都能获取到值的情况，两个值应该相同，都是imei的值。近期发现getDeviceId()和getImei()同时可用时获取到的值有时会不同，故跟踪一下源码查看一下区别，在此记录。 问题分析跟踪TelephonyManager的getDeviceId()和getImei()实现方法","text":"问题背景需要获取imei的值，很容易查询到使用TelephonyManager的getDeviceId()（在API Level 26 以上已标记为@Deprecated，在很多Android 26以上设备上也可继续使用）方法和getImei()方法（注释标记该方法需在API Level 26 以上调用，不过实测在有些26以下设备也可以调用到）Tips:Android Q 以上获取imei的需要READ_PRIVILEGED_PHONE_STATE 权限，该权限只有系统应用可以获取，普通应用使用以上两种方法获取均会抛出异常SecurityException，不过本文这不是重点，所以本文指的是Android Q以下相关设备。网上的说法这两个都是获取imei的方法，是使用的API Level不同，所以使用时一直以为如果遇到两个方法都能获取到值的情况，两个值应该相同，都是imei的值。近期发现getDeviceId()和getImei()同时可用时获取到的值有时会不同，故跟踪一下源码查看一下区别，在此记录。 问题分析跟踪TelephonyManager的getDeviceId()和getImei()实现方法 123456789101112131415161718192021222324252627 //android/telephony/TelephonyManager.java public String getDeviceId() &#123; try &#123; ITelephony telephony = getITelephony(); if (telephony == null) return null; return telephony.getDeviceId(mContext.getOpPackageName()); &#125; catch (RemoteException ex) &#123; return null; &#125; catch (NullPointerException ex) &#123; return null; &#125; &#125;public String getImei() &#123; return getImei(getSlotIndex()); &#125; public String getImei(int slotIndex) &#123; ITelephony telephony = getITelephony(); if (telephony == null) return null; try &#123; return telephony.getImeiForSlot(slotIndex, getOpPackageName(), getFeatureId()); &#125; catch (RemoteException ex) &#123; return null; &#125; catch (NullPointerException ex) &#123; return null; &#125; &#125; 接下来的工作都是跟踪对应的类调用getDeviceId():PhoneInterfaceManager.java –&gt;getDeviceId(String callingPackage)–&gt; getDeviceIdWithFeature(String callingPackage, String callingFeatureId)–&gt; PhoneFactory.getPhone(0).getDeviceId()getImei():PhoneInterfaceManager.java –&gt; getImeiForSlot(int slotIndex, String callingPackage, String callingFeatureId)–&gt; PhoneFactory.getPhone(0).getImei()PhoneInterfaceManager 作为TelephonyManager的 server 端，有很多方法，有兴趣的可以再深入了解。最终获取的是Phone中的值，Phone phone = PhoneFactory.getPhone(0);frameworks/opt/telephony/src/java/com/android/internal/telephony/Phone.java是一个抽象类,对应的子类包括GsmCdmaPhone.java、ImsPhoneBase.java,SipPhoneBase.java,通过命名大概能看出是手机应该使用的是GsmCdmaPhone.java,也可以看到ImsPhoneBase.java,SipPhoneBase.java 关于getDeviceId()和getImei()的返回值均为null,故只需关注GsmCdmaPhone.java即可 1234567891011121314151617181920212223//frameworks/opt/telephony/src/java/com/android/internal/telephony/GsmCdmaPhone.java@Overridepublic String getDeviceId() &#123; if (isPhoneTypeGsm()) &#123; return mImei; &#125; else &#123; CarrierConfigManager configManager = (CarrierConfigManager) mContext.getSystemService(Context.CARRIER_CONFIG_SERVICE); boolean force_imei = configManager.getConfigForSubId(getSubId()) .getBoolean(CarrierConfigManager.KEY_FORCE_IMEI_BOOL); if (force_imei) return mImei; String id = getMeid(); if ((id == null) || id.matches(\"^0*$\")) &#123; loge(\"getDeviceId(): MEID is not initialized use ESN\"); id = getEsn(); &#125; return id; &#125;&#125;@Overridepublic String getImei() &#123; return mImei;&#125; 结论很明显，getImei()是纯粹获取imei值的方法，getDeviceId中包含判断，如果isPhoneTypeGsm() ==false &amp;&amp; force_imei = false 也可能获取meid或Esn作为返回值。","categories":[{"name":"技术栈","slug":"技术栈","permalink":"http://ncmon.com/categories/技术栈/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://ncmon.com/tags/Android/"}]},{"title":"Kotlin学习笔记-较难理解的知识点？","slug":"kotlin-grasp-question-mark","date":"2020-02-28T14:01:52.000Z","updated":"2020-03-22T13:50:38.391Z","comments":true,"path":"post/kotlin-grasp-question-mark/","link":"http://ncmon.com/post/kotlin-grasp-question-mark/","permalink":"http://ncmon.com/post/kotlin-grasp-question-mark/","excerpt":"","text":"前言对我们来说，需求是学习的最大动力，比兴趣动力都足，之前对Kotlin一直是一知半解，没有系统性的学习，最近开始看很多open source都开始使用Kotlin语言来写了，很多社区的大神们也极力在推荐学习，再不学习都要跟不上了，刚好最近有时间学习一下，找了一本书《Kotlin核心编程》感觉讲的还比较容易理解，成体系，所以要集中系统的学习一下，为以后阅读代码，甚至转向Kotlin项目做些准备。 本系列主要是记录一下自己学习中感觉与Java相比，思想上比较难转换或者说难记忆的点，也有一些是觉得会很常用的知识点，加深记忆可供以后查询，同时也想分享给大家一下，好比上学时期的老师划重点，话不多说，看好小黑板~。 一. 极有特点的？1.1 ？单独的？代表可以为空@Nullable ，Kotlin默认定义属性时不能为null,写在定义属性时，表示该属性可空 1234val type:String = null //这样定义会报错，默认不允许为nullval type:String? = null //增加？代表可以定义为null//扩展一下val type = null //这样也不会报错，定义了一个无意义的属性Kotlin中的Nothing也不能修改为其他值 1.2 ?. 和!!.1seat?.student 直接对应Java中的Nullcheck,先判断是否为null，然后再调用，如果为空就返回null 同Java代码表示 12345if(seat != null)&#123; return seat.student&#125;else&#123; return null&#125; !!.是和?.对应的， ?.程序允许为空 !!.程序不允许为空 1seat!!.student 直接对应Java中的Nullcheck,先判断是否为null，然后再调用，如果为空就抛出异常 对应的Java代码表示 12345if(seat != null)&#123; return seat.student&#125;else&#123; throw new NullPointerException();&#125; 1.3 ?:1val c = a ?: b // 判断a是否为null，如果不为null返回a，如果为null返回b 同Java代码表示 1a != null ? c = a : c = b 1.4 as?1val x = y as? String 安全的类型转换运算符，默认不加？时，判断如果x不能转换为String类型是会跑出java.lang.ClassCastException 增加？后，x如果不能转换为String，会返回一个null值。 同Java代码 12345if (y instenceof String)&#123; x = (String)y;&#125;else&#123; x = null&#125;","categories":[{"name":"技术栈","slug":"技术栈","permalink":"http://ncmon.com/categories/技术栈/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://ncmon.com/tags/Android/"},{"name":"Kotlin","slug":"Kotlin","permalink":"http://ncmon.com/tags/Kotlin/"}]},{"title":"应用弹窗“此应用专为旧版Android打造，因此可能无法正常运行”","slug":"targetsdkversion_error_dialog","date":"2019-12-19T07:36:09.000Z","updated":"2020-01-05T12:41:18.363Z","comments":true,"path":"post/targetsdkversion_error_dialog/","link":"http://ncmon.com/post/targetsdkversion_error_dialog/","permalink":"http://ncmon.com/post/targetsdkversion_error_dialog/","excerpt":"","text":"应用弹窗“此应用专为旧版Android打造，因此可能无法正常运行安装在新设备上的应用出现了这个警告弹窗： 显然是个系统弹窗。看一下原因 Android源码分析追踪应用启动代码，忽略过程，本文不是重点，经过层层调用会进入到AppWarnings方法中，直接去看关键信息： 123456789101112131415161718192021//com/android/server/wm/AppWarnings.java/** * Shows the \"deprecated target sdk\" warning, if necessary. * * @param r activity record for which the warning may be displayed */public void showDeprecatedTargetDialogIfNeeded(ActivityRecord r) &#123; if (r.appInfo.targetSdkVersion &lt; Build.VERSION.MIN_SUPPORTED_TARGET_SDK_INT) &#123; mUiHandler.showDeprecatedTargetDialog(r); &#125;&#125;/** * Called when an activity is being started. * * @param r record for the activity being started */public void onStartActivity(ActivityRecord r) &#123; showUnsupportedCompileSdkDialogIfNeeded(r); showUnsupportedDisplaySizeDialogIfNeeded(r); showDeprecatedTargetDialogIfNeeded(r);&#125; 可以看到该弹窗的显示位置showDeprecatedTargetDialogIfNeeded(ActivityRecord)只有一个条件：targetSdkVersion&lt;Build.VERSION.MIN_SUPPORTED_TARGET_SDK_INT继续追踪Build.java 12345678910//android/os/Build.java/** * The current lowest supported value of app target SDK. Applications targeting * lower values may not function on devices running this SDK version. Its possible * values are defined in &#123;@link Build.VERSION_CODES&#125;. * * @hide */public static final int MIN_SUPPORTED_TARGET_SDK_INT = SystemProperties.getInt( \"ro.build.version.min_supported_target_sdk\", 0); 是设备中配置信息ro.build.version.min_supported_target_sdk目前发现在Android P 和Android Q中会出现该问题，查看测试机型中该配置的值Android Q设备中该值： Android P设备中该值： 这里有一个问题，既然是在每个Activity启动时会调用AppWarnings.java的onStartActivity方法，那会不会每次打开新Activity，都弹此对话框？ 答案：不会的，这里有一个小技巧，第一次弹出对话框后，用户如果选择“确定”，AMS会给此应用设置一个Flag标识：FLAG_HIDE_DEPRECATED_SDK。每次准备弹窗时，会先判断此标识值是否为true，如果是，说明已经提示过用户，无需再弹窗。代码如下： 123456789 public DeprecatedTargetSdkVersionDialog(final AppWarnings manager, Context context, ApplicationInfo appInfo) &#123;// ...final AlertDialog.Builder builder = new AlertDialog.Builder(context).setPositiveButton(R.string.ok, (dialog, which) -&gt;manager.setPackageFlag(mPackageName, AppWarnings.FLAG_HIDE_DEPRECATED_SDK, true)).setMessage(message).setTitle(label);// ... &#125; 问题结论结论很清晰：文章开头中提到的弹窗，在Android P设备中targetSdkVersion&lt;17的应用会弹出该弹窗，在Android Q设备中targetSdkVersion&lt;23的应用会弹出该弹窗。","categories":[{"name":"技术栈","slug":"技术栈","permalink":"http://ncmon.com/categories/技术栈/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://ncmon.com/tags/Android/"}]},{"title":"Android WebView必知必会(4)-Webview下载支持，与JavaScript的交互","slug":"webview-learning-JavaScript","date":"2019-03-25T16:06:30.000Z","updated":"2019-03-25T16:48:21.469Z","comments":true,"path":"post/webview-learning-JavaScript/","link":"http://ncmon.com/post/webview-learning-JavaScript/","permalink":"http://ncmon.com/post/webview-learning-JavaScript/","excerpt":"","text":"简介前面已经介绍了WebSettings,WebViewClient,WebChromeClient Android WebView必知必会(1)-WebViewClient Android WebView必知必会(2)-WebSettings Android WebView必知必会(3)-WebChromeClient 这一篇就记录一下WebView的其他重要功能 下载支持浏览器中有下载链接的如果不添加支持点击是没有反映的，常见的浏览器都有自己的下载管理功能，我们要实现的话需要怎么做呢，WebView有其对应的设置。 1234567891011/** * Registers the interface to be used when content can not be handled by * the rendering engine, and should be downloaded instead. This will replace * the current handler. * * @param listener an implementation of DownloadListener */ public void setDownloadListener(DownloadListener listener) &#123; checkThread(); mProvider.setDownloadListener(listener); &#125; 通过设置DownloadListener就能捕获到下载事件，针对下载链接做针对性的处理。 12345public interface DownloadListener &#123; public void onDownloadStart(String url, String userAgent, String contentDisposition, String mimetype, long contentLength);&#125; DownloadListener只有一个方法，点击下载链接即出发，通常有以下几种处理方式，大家参考以下吧。 传递给手机浏览器等能处理Url的应用处理这种最简单粗暴，会跳出选择可处理ACTION_VIEW的选择框，选择常规的浏览器都会支持，用户点击浏览器的话就是直接让手机自带浏览器APP处理该下载链接了。 123456webView.setDownloadListener((url, userAgent, contentDisposition, mimetype, contentLength) -&gt; &#123; Intent intent = new Intent(Intent.ACTION_VIEW); intent.addCategory(Intent.CATEGORY_BROWSABLE); intent.setData(Uri.parse(url)); startActivity(intent);&#125;); 使用DownloadManager处理就是使用系统的DownloadManager去处理下载任务了，这时就用到了其他参数 @param url 下载链接 @param contentDisposition 下载任务描述 @param mimetype 下载文件后缀","categories":[{"name":"技术栈","slug":"技术栈","permalink":"http://ncmon.com/categories/技术栈/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://ncmon.com/tags/Android/"}]},{"title":"Android WebView必知必会(3)-WebChromeClient","slug":"webview-learning-WebChromeClient","date":"2019-03-14T14:35:47.000Z","updated":"2019-03-23T06:29:14.825Z","comments":true,"path":"post/webview-learning-WebChromeClient/","link":"http://ncmon.com/post/webview-learning-WebChromeClient/","permalink":"http://ncmon.com/post/webview-learning-WebChromeClient/","excerpt":"简介😀WebChromeClient：当影响”浏览器”的事件到来时，就会通过WebChromeClient中的方法回调通知用法,所以WebChromeClient都是和我们平时使用浏览器需要的一些交互有密切的联系。","text":"简介😀WebChromeClient：当影响”浏览器”的事件到来时，就会通过WebChromeClient中的方法回调通知用法,所以WebChromeClient都是和我们平时使用浏览器需要的一些交互有密切的联系。 获取网页的加载进度 void onProgressChanged(WebView view, int newProgress) ； Tell the host application the current progress of loading a page. newProgress: Current page loading progress, represented by an integer between 0 and 100. 大家一定要注意，底层实现时，是利用handler来定时轮循当前进度的，每隔一定时间查询一次，所以每次拿到的进度数据是不一样的。也就是说如果页面较简单，可能会直接返回100，而跳过中间的各个数据。也就是说，除了100，其它任何一个数值不是一定返回的。所以大家如果要用到进度，除了数值100可以用等号来判断，其它一定要用大于号或小于号，如果用了等号，可能永远也不会执行到。 获取网页中的基本信息 void onReceivedIcon(WebView view, Bitmap icon) icon A Bitmap containing the favicon for the current page.网页中首部图标 void onReceivedTitle(WebView view, String title) title: A String containing the new title of the document. 网页中标题中的更改，首部标题 获取标题的时间主要取决于网页前端设置标题的位置，JS中的函数设置也在这里接收 void onReceivedTouchIconUrl(WebView view, String url, boolean precomposed) Notify the host application of the url for an apple-touch-icon(苹果图标). 苹果为iOS设备配备了apple-touch-icon私有属性，添加该属性，在iPhone,iPad,iTouch的safari浏览器上可以使用添加到主屏按钮将网站添加到主屏幕上，方便用户以后访问。apple-touch-icon 标签支持sizes属性，可以用来放置对应不同的设备。 url: The icon url.图片地址 precomposed: True if the url is for a precomposed touch icon. 标记为True的话使用原图 拦截网页中JS控制台消息当html中调用console相关输出的时候，就会通过onConsoleMessage进行通知 和alert,prompt,confirm不同，我们不需要强制设置WebChromeClient（但是仍需要setJavaScriptEnabled为true），当点击log按钮时，也会调用console相应的函数把日志打印出来。 可以获取到的信息有： 123456789101112131415@Overridepublic boolean onConsoleMessage(ConsoleMessage consoleMessage) &#123; Log.e(\"ncmon\", \"onConsoleMessage : \" + \"\\nmessage=\" + consoleMessage.message() + \"\\nlineNumber=\" + consoleMessage.lineNumber() + \"\\nmessageLevel=\" + consoleMessage.messageLevel() + \"\\nsourceId=\" + consoleMessage.sourceId()); return super.onConsoleMessage(consoleMessage);&#125;ncmon : onConsoleMessage : message=Uncaught TypeError: Cannot read property 'getItem' of null lineNumber=2 messageLevel=ERROR sourceId=https://m.baidu.com/?from=844b&amp;vit=fpschromium: [INFO:CONSOLE(2)] \"Uncaught TypeError: Cannot read property 'getItem' of null\", source: https://m.baidu.com/?from=844b&amp;vit=fps (2) 可以看到除了楼主输出的日志外，还有chromium的日志，这里也就要体现返回值的作用，如果返回true时，就表示拦截了console输出，系统就不再通过console输出出来了；如果返回false(默认值)，则表示没有拦截console输出，调用系统默认处理 123456public class ConsoleMessage &#123; private MessageLevel mLevel; private String mMessage; private String mSourceId; private int mLineNumber;&#125; 拦截网页中JS弹框三种类型的弹框 1234public boolean onJsAlert(WebView view, String url, String message, JsResult result) &#123; return false;&#125; 当网页调用alert()来弹出alert弹出框前回调，用以拦截alert()函数 1234public boolean onJsConfirm(WebView view, String url, String message, JsResult result) &#123; return false;&#125; 带有确定取消提示，当网页调用confirm()来弹出confirm弹出框前回调，用以拦截confirm()函数 1234public boolean onJsPrompt(WebView view, String url, String message, String defaultValue, JsPromptResult result) &#123; return false;&#125; 带有输入框的弹窗，当网页调用prompt()来弹出prompt弹出框前回调，用以拦截prompt()函数 处理JS弹框首先需要设置JavaScript支持，也必须设置WebChromeClient. 参数 url:page_with_curl:：弹出对话框的网页网址 message:speech_balloon::对话框的内容 result:closed_umbrella:: 返回给JavaScript的响应，JsResult.confirm()表示点击了弹出框的确定按钮，JsResult.cancel()则表示点击了弹出框的取消按钮。其中JsPromptResult也是继承JsResult的，只是多了输入的内容变量 (String mStringResult) 返回值 true Native 自行处理弹窗逻辑，不弹出alert弹窗了 false WebView 自行弹出alert对话框处理 如果是return true，此时我们必须手动调用JsResult的.confirm()或.cancel()方法，因为如果没有调用JsResult的confirm()或cancel()来告诉WebView你的处理结果，则WebView就会认为这个弹出框还一直弹在那里（虽然此时根本没有弹框弹出），所以之后你再点击alert按钮时，将会无效。这一点一定要注意。 打开和关闭Window1234public boolean onCreateWindow(WebView view, boolean isDialog, boolean isUserGesture, Message resultMsg) &#123; return false;&#125; 这个方法回调的前提需要设置WebView多窗口支持，就是浏览器的多个tab 1webSettings.setSupportMultipleWindows(true);//支持多窗口。如果设置为true 在Html中，超级链接标签a里有一个target属性，其意义是决定”是否在新窗口/标签页中打开链接”，如果不写target=”_blank”那么就是在相同的标签页打开，如果写了，就是在新的空白标签页中打开。比如： 1&lt;a href=\"https://www.taobao.com/\" title=\"淘宝\" target=\"_blank\"&gt;新窗口打开链接&lt;/a&gt; WebView默认是不支持target，点击上面的链接会在当前WebView中打开此链接。 完整逻辑如下 没有设置setSupportMultipleWindows属性为true 没有setWebChromeClient：点击此链接会在当前WebView中打开此链接 有setWebChromeClient：点击此链接会在当前WebView中打开此链接，不会回调onCreateWindow方法 有设置setSupportMultipleWindows属性为true 没有setWebChromeClient：点击此链接不会在当前WebView中打开此链接 有setWebChromeClient 没有重写onCreateWindow方法：点击此链接不会在当前WebView中打开此链接，会回调onCreateWindow方法 有重写onCreateWindow方法：点击此链接不会在当前WebView中打开此链接，会回调onCreateWindow方法，会在你新创建的WebView中打开此链接 1234567891011121314151617181920@Overridepublic boolean onCreateWindow(WebView webView, boolean isDialog, boolean isUserGesture, Message resultMsg) &#123; Log.i(\"bqt\", \"【onCreateWindow】 \" + isDialog + \" \" + isUserGesture + \"\\n详细信息\" + resultMsg.toString()); if (activity != null) &#123; WebView childView = new WebView(activity);//Parent WebView cannot host it's own popup window. childView.setBackgroundColor(Color.GREEN); childView.setWebViewClient(new WebViewClient() &#123; @Override public boolean shouldOverrideUrlLoading(WebView view, String url) &#123; Log.i(\"bqt\", \"【shouldOverrideUrlLoading-子】\"); activity.startActivity(new Intent(Intent.ACTION_VIEW, Uri.parse(url))); return true; &#125; &#125;); WebView.WebViewTransport transport = (WebView.WebViewTransport) resultMsg.obj; transport.setWebView(childView);//setWebView和getWebView两个方法 resultMsg.sendToTarget(); return true; &#125; else return super.onCreateWindow(webView, isDialog, isUserGesture, resultMsg);//默认是returns false&#125; 感觉浏览器才会用到这个API,常规应用基本都是打开自己定制的Html页面 对应的还有一个关闭Window的API，在JS调用window.close()方法时会回调此方法【关闭窗口】 1public void onCloseWindow(WebView window) &#123;&#125; 文件选择器这个方法在项目中很常用，Html中如果需要选择本机文件就需要把文件传过去。基本操作为打开文件管理器再把选择的文件传到网页中。我也有用到，就贴一下完整的代码片段。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364//For Android &gt;= 4.1public void openFileChooser(ValueCallback&lt;Uri&gt; valueCallback, String acceptType, String capture) &#123; uploadMessage = valueCallback; openImageChooserActivity();&#125;// For Android &gt;= 5.0@Overridepublic boolean onShowFileChooser(WebView webView, ValueCallback&lt;Uri[]&gt; filePathCallback, WebChromeClient.FileChooserParams fileChooserParams) &#123; uploadMessageAboveL = filePathCallback; Intent i = new Intent(Intent.ACTION_GET_CONTENT); i.addCategory(Intent.CATEGORY_OPENABLE); if (fileChooserParams != null &amp;&amp; fileChooserParams.getAcceptTypes() != null &amp;&amp; fileChooserParams.getAcceptTypes().length &gt; 0) &#123; i.setType(fileChooserParams.getAcceptTypes()[0]); &#125; else &#123; i.setType(\"*/*\"); &#125; startActivityForResult(Intent.createChooser(i, \"File Chooser\"), FILECHOOSER_RESULTCODE); return true;&#125; @Override protected void onActivityResult(int requestCode, int resultCode, Intent data) &#123; super.onActivityResult(requestCode, resultCode, data); if (requestCode == FILE_CHOOSER_RESULT_CODE) &#123; if (null == uploadMessage &amp;&amp; null == uploadMessageAboveL) &#123; return; &#125; Uri result = data == null || resultCode != RESULT_OK ? null : data.getData(); if (uploadMessageAboveL != null) &#123; onActivityResultAboveL(requestCode, resultCode, data); &#125; else if (uploadMessage != null) &#123; uploadMessage.onReceiveValue(result); uploadMessage = null; &#125; &#125; &#125; @TargetApi(Build.VERSION_CODES.LOLLIPOP) private void onActivityResultAboveL(int requestCode, int resultCode, Intent intent) &#123; if (requestCode != FILE_CHOOSER_RESULT_CODE || uploadMessageAboveL == null) &#123; return; &#125; Uri[] results = null; if (resultCode == Activity.RESULT_OK) &#123; if (intent != null) &#123; String dataString = intent.getDataString(); ClipData clipData = intent.getClipData(); if (clipData != null) &#123; results = new Uri[clipData.getItemCount()]; for (int i = 0; i &lt; clipData.getItemCount(); i++) &#123; ClipData.Item item = clipData.getItemAt(i); results[i] = item.getUri(); &#125; &#125; if (dataString != null) &#123; results = new Uri[]&#123;Uri.parse(dataString)&#125;; &#125; &#125; &#125; uploadMessageAboveL.onReceiveValue(results); uploadMessageAboveL = null; &#125; @params filePathCallback: 提供要上传的文件的路径列表, or NULL to cancel. Must only be called if the showFileChooser implementations returns true. @params fileChooserParams: 描述要打开的文件选择器的模式，以及与之一起使用的选项。 视频(全屏)播放123public Bitmap getDefaultVideoPoster() &#123; return null;&#125; Html中，视频（video）控件在没有播放的时候将给用户展示一张“海报”图片（预览图）。其预览图是由Html中video标签的poster属性来指定的。如果开发者没有设置poster属性, 则可以通过这个方法来设置默认的预览图。 12345&lt;video controls poster=\"/images/w3school.gif\"&gt; &lt;source src=\"movie.mp4\" type=\"video/mp4\"&gt; &lt;source src=\"movie.ogg\" type=\"video/ogg\"&gt; Your browser does not support the video tag.&lt;/video&gt; 123public View getVideoLoadingProgressView() &#123; return null;&#125; 播放视频时，在第一帧呈现之前，需要花一定的时间来进行数据缓冲。ChromeClient可以使用这个函数来提供一个在数据缓冲时显示的视图。 例如,ChromeClient可以在缓冲时显示一个转轮动画。 12public void onShowCustomView(View view, CustomViewCallback callback) &#123;&#125;;public void onHideCustomView() &#123;&#125; 通知主机应用webview需要显示一个custom view，主要是用在视频全屏 HTML5 Video support。 网页中有H5播放flash video的时候按下全屏按钮将会调用到这个方法，一般用作设置网页播放全屏操作。 获取地理位置123public void onGeolocationPermissionsShowPrompt(String origin, GeolocationPermissions.Callback callback) &#123;&#125;public void onGeolocationPermissionsHidePrompt() &#123;&#125; 12345678910111213141516171819public class GeolocationPermissions &#123; /** * A callback interface used by the host application to set the Geolocation * permission state for an origin. */ public interface Callback &#123; /** * Sets the Geolocation permission state for the supplied origin. * * @param origin the origin for which permissions are set * @param allow whether or not the origin should be allowed to use the * Geolocation API * @param retain whether the permission should be retained beyond the * lifetime of a page currently being displayed by a * WebView */ public void invoke(String origin, boolean allow, boolean retain); &#125;;&#125; JavaScript中有调用定位的API时会调用本方法 @param origin 来源，谁调用的，传回给谁 @param allow 是否允许本次定位 @param retain 是否保持允许定位状态，传递了true后，本WebView之后都可以获得当前位置信息。 对应的onGeolocationPermissionsHidePrompt（）就是通知应用程序，地理位置权限请求已被取消 请求权限123456789101112131415161718192021 /** * Notify the host application that web content is requesting permission to * access the specified resources and the permission currently isn't granted * or denied. The host application must invoke &#123;@link PermissionRequest#grant(String[])&#125; * or &#123;@link PermissionRequest#deny()&#125;. * * If this method isn't overridden, the permission is denied. * * @param request the PermissionRequest from current web content. */public void onPermissionRequest(PermissionRequest request) &#123; request.deny();&#125;/** * Notify the host application that the given permission request * has been canceled. Any related UI should therefore be hidden. * * @param request the PermissionRequest that needs be canceled. */public void onPermissionRequestCanceled(PermissionRequest request) &#123;&#125; 1234567891011public abstract class PermissionRequest &#123; public final static String RESOURCE_VIDEO_CAPTURE = \"android.webkit.resource.VIDEO_CAPTURE\"; public final static String RESOURCE_AUDIO_CAPTURE = \"android.webkit.resource.AUDIO_CAPTURE\"; public final static String RESOURCE_PROTECTED_MEDIA_ID = \"android.webkit.resource.PROTECTED_MEDIA_ID\"; public final static String RESOURCE_MIDI_SYSEX = \"android.webkit.resource.MIDI_SYSEX\"; public abstract Uri getOrigin(); public abstract String[] getResources(); public abstract void grant(String[] resources); public abstract void deny();&#125; @method getorigin()获取来源 @method getResources()获取请求的权限列表 @method grant ()允许的权限列表 @method deny()拒绝了权限 需要的就是PermissRequest中定义的四个常亮代表的权限，关于权限的使用是其他知识点，大家可以看看这个栗子。 其他方法123456789/** *获得所有访问历史项目的列表，用于链接着色。 */public void getVisitedHistory(ValueCallback&lt;String[]&gt; callback) &#123;&#125;/** *webview请求得到焦点，发生这个主要是当前webview不是前台状态，是后台webview。 */public void onRequestFocus(WebView view) &#123;&#125;","categories":[{"name":"技术栈","slug":"技术栈","permalink":"http://ncmon.com/categories/技术栈/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://ncmon.com/tags/Android/"}]},{"title":"Android WebView必知必会(2)-WebSettings","slug":"webview-learning-WebSettings","date":"2019-03-07T15:29:48.000Z","updated":"2019-03-23T06:16:15.385Z","comments":true,"path":"post/webview-learning-WebSettings/","link":"http://ncmon.com/post/webview-learning-WebSettings/","permalink":"http://ncmon.com/post/webview-learning-WebSettings/","excerpt":"简介WebSettings 看名称就明显了，是对WebView的一些基础设置，网页中需要的一些支持均需要在WebSettings 中设置。获取方式也很简单,通过WebView的方法获得即可。1234public WebSettings getSettings() &#123; checkThread(); return mProvider.getSettings();&#125;","text":"简介WebSettings 看名称就明显了，是对WebView的一些基础设置，网页中需要的一些支持均需要在WebSettings 中设置。获取方式也很简单,通过WebView的方法获得即可。1234public WebSettings getSettings() &#123; checkThread(); return mProvider.getSettings();&#125; 记录下对应的API含义，基本是直接找来的，大部分在项目用有验证，如果有使用偏差会随时回来修改，大家参考下。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232/** * 是否支持缩放，配合方法setBuiltInZoomControls使用，默认true */setSupportZoom(boolean support) /** * 是否需要用户手势来播放Media，默认true */setMediaPlaybackRequiresUserGesture(boolean require) /** * 是否使用WebView内置的缩放组件，由浮动在窗口上的缩放控制和手势缩放控制组成，默认false */setBuiltInZoomControls(boolean enabled) /** * 是否显示窗口悬浮的缩放控制，默认true */setDisplayZoomControls(boolean enabled) /** * 是否允许访问WebView内部文件，默认true */setAllowFileAccess(boolean allow) /** * 是否允许获取WebView的内容URL ，可以让WebView访问ContentPrivider存储的内容。 默认true */setAllowContentAccess(boolean allow) /** * 是否启动概述模式浏览界面，当页面宽度超过WebView显示宽度时，缩小页面适应WebView。默认false */setLoadWithOverviewMode(boolean overview) /** * 是否保存表单数据，默认false */setSaveFormData(boolean save) /** * 设置页面文字缩放百分比，默认100% */setTextZoom(int textZoom) /** * 是否支持ViewPort的meta tag属性，如果页面有ViewPort meta tag 指定的宽度，则使用meta tag指定的值，否则默认使用宽屏的视图窗口 */setUseWideViewPort(boolean use) /** * 是否支持多窗口，如果设置为true ，WebChromeClient#onCreateWindow方法必须被主程序实现，默认false */setSupportMultipleWindows(boolean support) /** * 指定WebView的页面布局显示形式，调用该方法会引起页面重绘。默认LayoutAlgorithm#NARROW_COLUMNS */setLayoutAlgorithm(LayoutAlgorithm l) /** * 设置标准的字体族，默认”sans-serif”。font-family 规定元素的字体系列。 * font-family 可以把多个字体名称作为一个“回退”系统来保存。如果浏览器不支持第一个字体， * 则会尝试下一个。也就是说，font-family 属性的值是用于某个元素的字体族名称或/及类族名称的一个 * 优先表。浏览器会使用它可识别的第一个值。 */setStandardFontFamily(String font) /** * 设置混合字体族。默认”monospace” */setFixedFontFamily(String font) /** * 设置SansSerif字体族。默认”sans-serif” */setSansSerifFontFamily(String font) /** * 设置SerifFont字体族，默认”sans-serif” */setSerifFontFamily(String font) /** * 设置CursiveFont字体族，默认”cursive” */setCursiveFontFamily(String font) /** * 设置FantasyFont字体族，默认”fantasy” */setFantasyFontFamily(String font) /** * 设置最小字体，默认8. 取值区间[1-72]，超过范围，使用其上限值。 */setMinimumFontSize(int size) /** * 设置最小逻辑字体，默认8. 取值区间[1-72]，超过范围，使用其上限值。 */setMinimumLogicalFontSize(int size) /** * 设置默认字体大小，默认16，取值区间[1-72]，超过范围，使用其上限值。 */setDefaultFontSize(int size) /** * 设置默认填充字体大小，默认16，取值区间[1-72]，超过范围，使用其上限值。 */setDefaultFixedFontSize(int size) /** * 设置是否加载图片资源，注意：方法控制所有的资源图片显示，包括嵌入的本地图片资源。 * 使用方法setBlockNetworkImage则只限制网络资源图片的显示。值设置为true后， * webview会自动加载网络图片。默认true */setLoadsImagesAutomatically(boolean flag) /** * 是否加载网络图片资源。注意如果getLoadsImagesAutomatically返回false，则该方法没有效果。 * 如果使用setBlockNetworkLoads设置为false，该方法设置为false，也不会显示网络图片。 * 当值从true改为false时。WebView会自动加载网络图片。 */setBlockNetworkImage(boolean flag) /** * 设置是否加载网络资源。注意如果值从true切换为false后，WebView不会自动加载， * 除非调用WebView#reload().如果没有android.Manifest.permission#INTERNET权限， * 值设为false，则会抛出java.lang.SecurityException异常。 * 默认值：有android.Manifest.permission#INTERNET权限时为false，其他为true。 */setBlockNetworkLoads(boolean flag) /** * 设置是否允许执行JS。 */setJavaScriptEnabled(boolean flag) /** * 是否允许Js访问任何来源的内容。包括访问file scheme的URLs。考虑到安全性， * 限制Js访问范围默认禁用。注意：该方法只影响file scheme类型的资源，其他类型资源如图片类型的， * 不会受到影响。ICE_CREAM_SANDWICH_MR1版本以及以下默认为true，JELLY_BEAN版本 * 以上默认为false */setAllowUniversalAccessFromFileURLs(boolean flag) /** * 是否允许Js访问其他file scheme的URLs。包括访问file scheme的资源。考虑到安全性， * 限制Js访问范围默认禁用。注意：该方法只影响file scheme类型的资源，其他类型资源如图片类型的， * 不会受到影响。如果getAllowUniversalAccessFromFileURLs为true，则该方法被忽略。 * ICE_CREAM_SANDWICH_MR1版本以及以下默认为true，JELLY_BEAN版本以上默认为false */setAllowFileAccessFromFileURLs(boolean flag) /** * 设置存储定位数据库的位置，考虑到位置权限和持久化Cache缓存，Application需要拥有指定路径的 * write权限 */setGeolocationDatabasePath(String databasePath) /** * 是否允许Cache，默认false。考虑需要存储缓存，应该为缓存指定存储路径setAppCachePath */setAppCacheEnabled(boolean flag) /** * 设置Cache API缓存路径。为了保证可以访问Cache，Application需要拥有指定路径的write权限。 * 该方法应该只调用一次，多次调用自动忽略。 */setAppCachePath(String appCachePath) /** * 是否允许数据库存储。默认false。查看setDatabasePath API 如何正确设置数据库存储。 * 该设置拥有全局特性，同一进程所有WebView实例共用同一配置。注意：保证在同一进程的任一WebView * 加载页面之前修改该属性，因为在这之后设置WebView可能会忽略该配置 */setDatabaseEnabled(boolean flag) /** * 是否存储页面DOM结构，默认false。 */setDomStorageEnabled(boolean flag) /** * 是否允许定位，默认true。注意：为了保证定位可以使用，要保证以下几点： * Application 需要有android.Manifest.permission#ACCESS_COARSE_LOCATION的权限 * Application 需要实现WebChromeClient#onGeolocationPermissionsShowPrompt的回调， * 接收Js定位请求访问地理位置的通知 */setGeolocationEnabled(boolean flag) /** * 是否允许JS自动打开窗口。默认false */setJavaScriptCanOpenWindowsAutomatically(boolean flag) /** * 设置页面的编码格式，默认UTF-8 */setDefaultTextEncodingName(String encoding) /** * 设置WebView代理，默认使用默认值 */setUserAgentString(String ua) /** * 通知WebView是否需要设置一个节点获取焦点当 * WebView#requestFocus(int,android.graphics.Rect)被调用的时候，默认true */setNeedInitialFocus(boolean flag) /** * 基于WebView导航的类型使用缓存：正常页面加载会加载缓存并按需判断内容是否需要重新验证。 * 如果是页面返回，页面内容不会重新加载，直接从缓存中恢复。setCacheMode允许客户端根据指定的模式来 * 使用缓存。 * LOAD_DEFAULT 默认加载方式 * LOAD_CACHE_ELSE_NETWORK 按网络情况使用缓存 * LOAD_NO_CACHE 不使用缓存 * LOAD_CACHE_ONLY 只使用缓存 */setCacheMode(int mode) /** * 设置加载不安全资源的WebView加载行为。KITKAT版本以及以下默认为MIXED_CONTENT_ALWAYS_ALLOW方 * 式，LOLLIPOP默认MIXED_CONTENT_NEVER_ALLOW。强烈建议：使用MIXED_CONTENT_NEVER_ALLOW */setMixedContentMode(int mode)","categories":[{"name":"技术栈","slug":"技术栈","permalink":"http://ncmon.com/categories/技术栈/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://ncmon.com/tags/Android/"}]},{"title":"Android WebView必知必会(1)-WebViewClient","slug":"webview-learning-WebViewClient","date":"2019-02-23T06:27:48.000Z","updated":"2019-03-20T14:37:20.444Z","comments":true,"path":"post/webview-learning-WebViewClient/","link":"http://ncmon.com/post/webview-learning-WebViewClient/","permalink":"http://ncmon.com/post/webview-learning-WebViewClient/","excerpt":"项目中遇到了混合开发怎么办，不需要慌，Android提供的WebView已经非常强大，可以和前端同学配合好完成非常多的事情。配合之前呢就需要对WebView做一个全面的了解，看看WebView能做些什么，又怎么去做这些事情，又会遇到哪些问题。 WebView简介从Android4.4系统开始，Chromium内核取代了Webkit内核，正式地接管了WebView的渲染工作。Chromium是一个开源的浏览器内核项目，基于Chromium开源项目修改实现的浏览器非常多，包括最著名的Chrome浏览器，以及一众国内浏览器（360浏览器、QQ浏览器等）。其中Chromium在Android上面的实现是Android System WebView。","text":"项目中遇到了混合开发怎么办，不需要慌，Android提供的WebView已经非常强大，可以和前端同学配合好完成非常多的事情。配合之前呢就需要对WebView做一个全面的了解，看看WebView能做些什么，又怎么去做这些事情，又会遇到哪些问题。 WebView简介从Android4.4系统开始，Chromium内核取代了Webkit内核，正式地接管了WebView的渲染工作。Chromium是一个开源的浏览器内核项目，基于Chromium开源项目修改实现的浏览器非常多，包括最著名的Chrome浏览器，以及一众国内浏览器（360浏览器、QQ浏览器等）。其中Chromium在Android上面的实现是Android System WebView。 从Android5.0系统开始，WebView移植成了一个独立的apk，可以不依赖系统而独立存在和更新，我们可以在系统-&gt;设置-&gt;Android System WebView看到WebView的当前版本。 从Android7.0系统开始，如果系统安装了Chrome (version&gt;51)，那么Chrome将会直接为应用的WebView提供渲染，WebView版本会随着Chrome的更新而更新，用户也可以选择WebView的服务提供方（在开发者选项-&gt;WebView Implementation里），WebView可以脱离应用，在一个独立的沙盒进程中渲染页面（需要在开发者选项里打开）。 从Android8.0系统开始，默认开启WebView多进程模式，即WebView运行在独立的沙盒进程中。 WebViewClient抛砖WebView加载在线网页必备，如果不设置，会直接跳转打开浏览器应用加载网页！同时包含很多有用的回调函数。 举一个小栗子： 通常加载一个网页都需要一定的时间，这时候就需要一个loading友好提示一下用户，正在加载，加载完成后隐藏它。这个怎么实现呢，就需要用到WebViewClient了，WebViewClient包含了很多网页加载需要用到的回调。 12345678910111213mWebView.setWebViewClient(new WebViewClient()&#123; @Override public void onPageStarted(WebView view, String url, Bitmap favicon) &#123; super.onPageStarted(view, url, favicon); Log.d(TAG,\"onPageStarted\"); &#125; @Override public void onPageFinished(WebView view, String url) &#123; super.onPageFinished(view, url); Log.d(TAG,\"onPageFinished\"); &#125;&#125;); WebView.setWebViewClient方法设置WebViewClient回调，重写了两个方法，onPageStarted会在加载网页时调用，onPageFinished就代表加载完成了。利用这两个方法就能完成loading的控制。在onPageFinished中也可以通过WebView.getTitle（）可获得当前网页加载完时的title(这里指Html文件中head中的title)等，当然对某些网页时不准的，因为网页中可能会通过JS代码动态的修改title,这个操作是在onPageFinish()之后进行的，这个title在另外的函数可以获取到，总结WebChromeClient的时候会讲到。 常用函数简介不一定全都会用到，先学习一下，以备不时之需，会挑几个非常常用的总结下使用场景。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273/** * 在开始加载网页时会回调 */public void onPageStarted(WebView view, String url, Bitmap favicon) /** * 在结束加载网页时会回调 */public void onPageFinished(WebView view, String url)/** * 拦截 url 跳转,在里边添加点击链接跳转或者操作 */@Deprecatedpublic boolean shouldOverrideUrlLoading(WebView view, String url)//sdk&gt;=24 public boolean shouldOverrideUrlLoading(WebView view, WebResourceRequest request)/** * 在每一次请求资源时，都会通过这个函数来回调,请求资源的主机应用程序允许应用程序返回数据，如果该方法返回 * null，WebView将会按照平常一样继续加载；否则，返回的内容将会被使用。该方法在独立线程而非UI线程中回 * 调，因此访问私有数据或系统视图时应该谨慎行事。 */@Deprecatedpublic WebResourceResponse shouldInterceptRequest(WebView view,String url) &#123; return null;&#125;public WebResourceResponse shouldInterceptRequest(WebView view,WebResourceRequest request) &#123; return shouldInterceptRequest(view, request.getUrl().toString());&#125;/** *加载资源完成（与shouldInterceptRequest对应） */ public void onLoadResource(WebView view, String url) /** * 加载错误的时候会回调，在其中可做错误处理，比如再请求加载一次，或者提示自定义的网路问题页面 */@Deprecatedpublic void onReceivedError(WebView view, int errorCode,String description, String failingUrl)//sdk&gt;=23 public void onReceivedError(WebView view, WebResourceRequest request, WebResourceError error)/** * 当接收到https错误时，会回调此函数，在其中可以做错误处理 */public void onReceivedSslError(WebView view, SslErrorHandler handler,SslError error)/** * 回调该方法，处理SSL认证请求 */public void onReceivedClientCertRequest(WebView view, ClientCertRequest request)/** * 页面大小改变后回调该方法，获取缩放前后大小 */public void onScaleChanged(WebView view, float oldScale, float newScale)/** * 更新历史记录 * @param isReload 代表Url是重新载入的 */public void doUpdateVisitedHistory(WebView view, String url, boolean isReload)/** * 账户自动登录 */public void onReceivedLoginRequest(WebView view, String realm,String account, String args) /** * 通知主程序输入事件不是由WebView调用。是否让主程序处理WebView未处理的Input Event。 * 除了系统按键，WebView总是消耗掉输入事件或shouldOverrideKeyEvent返回true。 * 该方法由event 分发异步调用。注意：如果事件为MotionEvent，则事件的生命周期只存在方法调用过程中， * 如果WebViewClient想要使用这个Event，则需要复制Event对象。 */onUnhandledInputEvent(WebView view, InputEvent event)/** * 如果浏览器需要重新发送POST请求，可以通过这个时机来处理。默认是不重新发送数据。 参数说明 * @param dontResend 浏览器不需要重新发送的参数 * @param resend浏览器需要重新发送的参数 */@Overridepublic void onFormResubmission(WebView view, Message dontResend,Message resend)！ shouldOverrideUrlLoading非常重要的方法，第一个就需要说明，重定向，超链接都会用的方法，这个函数在加载超链接时会回调，由于这个函数是在加载Url之前调用，返回值true代表拦截处理就不再继续加载了，返回false则继续加载，所以如果需要做一些白名单黑名单操作可以在这里处理它们。 123public boolean shouldOverrideUrlLoading(WebView view, String url) &#123; return false;&#125; 默认既返回false。所以如果没有其他设置需求可以采用设置一个默认的WebViewClient既能保持正常加载网页。 1mWebView.setWebViewClient(new WebViewClient()); 有重载方法，在SDK&gt;=24调用，所以如果需要处理，需要两个函数都重写 1public boolean shouldOverrideUrlLoading(WebView view, WebResourceRequest request) onReceivedError接收网络错误，典型使用场景是加载404页面 12345678public void onReceivedError(WebView view, WebResourceRequest request, WebResourceError error) &#123; //如果是主frame的话就执行方法，要是在其他比如iframes就会不执行 if (request.isForMainFrame()) &#123; onReceivedError(view,error.getErrorCode(), rror.getDescription().toString(),request.getUrl().toString()); &#125; //处理加载本地错误页面 mWebView.loadUrl(\"file:///android_asset/http_error.html\")&#125; WebResourceError包含了错误信息,其中的ErrorCode对应WebViewClient中的常量ERROR_*可以做对应处理 123456public abstract class WebResourceError &#123; public abstract int getErrorCode(); public abstract CharSequence getDescription(); @SystemApi public WebResourceError() &#123;&#125;&#125; onReceivedSslError很多帖子都介绍了这个方法，顾名思义与处理SSL错误有关，也就是处理https的请求时验证出错，看到的很多例子都是以以前的12306网站为例，以前的12306是自签名证书，所以用chrome打开时会出现警告，如果用WebView加载这里就会回调onReceivedSslError函数，笔者写这篇笔记时12306已经是公共证书了，也就没有这个错误验证了。暂时使用自己的理解介绍一下，以后发现可用网站再验证： 该函数的默认实现为 123public void onReceivedSslError(WebView view, SslErrorHandler handler,SslError error) &#123; handler.cancel();&#125; SslErrorHandler.cancel()就是结束了Ssl处理，也就不会继续加载了，这里子类可以重写处理逻辑为： 1234public void onReceivedSslError(WebView view, SslErrorHandler handler,SslError error) &#123; //super.onReceivedSslError(view, handler, error); handler.proceed();&#125; 改变了SslErrorHandler的处理，使其能继续验证证书，正常打开该网页。 需要注意的是如果有回调了onReceivedSslError，是不会同时回调onReceivedError的 WebViewClient还有很多没有介绍到的方法，有机会还是找一些应用场景试验下再行补充，这篇文章先到这里吧，之后再总结下常用设置和WebChromeClient相关。","categories":[{"name":"技术栈","slug":"技术栈","permalink":"http://ncmon.com/categories/技术栈/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://ncmon.com/tags/Android/"},{"name":"WebView","slug":"WebView","permalink":"http://ncmon.com/tags/WebView/"}]},{"title":"微博登陆，QQ登录错误码","slug":"threee-way-login-errorcode","date":"2018-12-20T14:37:09.000Z","updated":"2019-03-23T06:28:39.193Z","comments":true,"path":"post/threee-way-login-errorcode/","link":"http://ncmon.com/post/threee-way-login-errorcode/","permalink":"http://ncmon.com/post/threee-way-login-errorcode/","excerpt":"记录一下第三方登录的错误码，遇到的总结起来，以便排查问题。","text":"记录一下第三方登录的错误码，遇到的总结起来，以便排查问题。 Weibo Login OAuth2.0 错误码(error) 错误编号(error_code) 错误描述(error_description) redirect_uri_mismatch 21322 重定向地址不匹配 invalid_request 21323 请求不合法 invalid_client 21324 client_id或client_secret参数无效 invalid_grant 21325 提供的Access Grant是无效的、过期的或已撤销的 unauthorized_client 21326 客户端没有权限 expired_token 21327 token过期 unsupported_grant_type 21328 不支持的 GrantType unsupported_response_type 21329 不支持的 ResponseType access_denied 21330 用户或授权服务器拒绝授予数据访问权限 temporarily_unavailable 21331 服务暂时无法访问 appkey permission denied 21337 应用权限不足 QQ Login OAuth2.0 错误码 含义说明 0 成功。 100000 缺少参数response_type或response_type非法。 100001 缺少参数client_id。100002缺少参数client_secret。 100003 http head中缺少Authorization。 100004 缺少参数grant_type或grant_type非法。 100005 缺少参数code。 100006 缺少refresh token。 100007 缺少access token。 100008 该appid不存在。 100009 client_secret（即appkey）非法。 100010 回调地址不合法，常见原因请见：回调地址常见问题及修改方法100011APP不处于上线状态。 100012 HTTP请求非post方式。 100013 access token非法。 100014 access token过期。 token过期时间为3个月。如果存储的access token过期，请重新走登录流程，根据使用Authorization_Code获取Access_Token或使用Implicit_Grant方式获取Access_Token获取新的access token值。 100015 access token废除。 token被回收，或者被用户删除。请重新走登录流程，根据使用Authorization_Code获取Access_Token或使用Implicit_Grant方式获取Access_Token获取新的access token值。 100016 access token验证失败。 100017 获取appid失败。 100018 获取code值失败。 100019 用code换取access token值失败。 100020 code被重复使用。 100021 获取access token值失败。 100022 获取refresh token值失败。 100023 获取app具有的权限列表失败。 100024 获取某OpenID对某appid的权限列表失败。 100025 获取全量api信息、全量分组信息。 100026 设置用户对某app授权api列表失败。 100027 设置用户对某app授权时间失败。 100028 缺少参数which。 100029 错误的http请求。 100030 用户没有对该api进行授权，或用户在腾讯侧删除了该api的权限。请用户重新走登录、授权流程，对该api进行授权。 100031 第三方应用没有对该api操作的权限。请发送邮件进行OpenAPI权限申请。 100032 过载，一开始未细分时可以用。 100033 缺少UIN参数。 100034 缺少skey参数 100035 用户未登陆。 100036 RefreshToken失效。 100037 RefreshToken已过期 100038 RefreshToken已废除 100039 RefreshToken到达调用上限。 100040 RefreshToken的AppKey非法。 100041 RefreshToken,AppID非法。 100042 RefreshToken非法。 100043 APP处于暂停状态。 100044 错误的sign，Md5校验失败，请求签名与官网填写的签名不一致。 100045 用户改密token失效。 100046 g_tk校验失败。 100048 没有设置companyID。 100049 APPID没有权限(get_unionid)。 100050 OPENID解密失败，一般是openid和appid不匹配。 100051 调试模式无权限。 110401 请求的应用不存在。 110404 请求参数缺少appid。 110405 登录请求被限制，请稍后在登录。 110406 应用没有通过审核。 110500 获取用户授权信息失败。 110501 获取应用的授权信息失败 110502 设置用户授权失败 110503 获取token失败 110504 系统内部错误 110505 参数错误 110506 获取APP info信息失败 110506 校验APP info 签名信息失败 110508 获取code失败 110509 SKEY校验失败 110510 Disable","categories":[{"name":"技术栈","slug":"技术栈","permalink":"http://ncmon.com/categories/技术栈/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://ncmon.com/tags/Android/"}]},{"title":"NestedScrollView嵌套RecyclerView滑动冲突","slug":"design-clear-of-mines-2","date":"2018-11-21T15:09:46.000Z","updated":"2018-11-21T15:31:11.128Z","comments":true,"path":"post/design-clear-of-mines-2/","link":"http://ncmon.com/post/design-clear-of-mines-2/","permalink":"http://ncmon.com/post/design-clear-of-mines-2/","excerpt":"问题描述Android使用disign 中控件NestedScrollView+RecyclerView嵌套时上下滑动会有明显的阻塞感，显然是遇到了滑动冲突","text":"问题描述Android使用disign 中控件NestedScrollView+RecyclerView嵌套时上下滑动会有明显的阻塞感，显然是遇到了滑动冲突12345678910111213&lt;android.support.v4.widget.NestedScrollView android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:fillViewport=\"true\" app:layout_behavior=\"@string/appbar_scrolling_view_behavior\"&gt; &lt;android.support.v7.widget.RecyclerView android:id=\"@+id/recycler_view\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:layout_marginTop=\"2dp\" app:layout_constraintTop_toBottomOf=\"@id/space1\"/&gt;&lt;/android.support.v4.widget.NestedScrollView&gt; 解决方案在XML中 可以对RecyclerView 设置 android:nestedScrollingEnabled=”false”不过这样只支持Android 21以上的版本，对应的设置RecyclerView的属性mRecyclerView.setNestedScrollingEnabled(false)由于是support支持库中的方法即可兼容低版本。","categories":[{"name":"错误志","slug":"错误志","permalink":"http://ncmon.com/categories/错误志/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://ncmon.com/tags/Android/"},{"name":"Design","slug":"Design","permalink":"http://ncmon.com/tags/Design/"},{"name":"error","slug":"error","permalink":"http://ncmon.com/tags/error/"}]},{"title":"NestedScrollView嵌套ViewPager 显示冲突","slug":"design-clear-of-mines-1","date":"2018-11-21T15:04:11.000Z","updated":"2018-11-21T15:41:36.686Z","comments":true,"path":"post/design-clear-of-mines-1/","link":"http://ncmon.com/post/design-clear-of-mines-1/","permalink":"http://ncmon.com/post/design-clear-of-mines-1/","excerpt":"问题描述Android使用disign中自带控件CoordinatorLayout+TabLayout+NestedScrollView+ViewPager来实现可折叠头部的也可横下滑动的列表的页面NestedScrollView中嵌套了ViewPager来展示不同的Tab滑动展示，ViewPager显示的高度为0，从AndroidStudio预览页面即可看到。","text":"问题描述Android使用disign中自带控件CoordinatorLayout+TabLayout+NestedScrollView+ViewPager来实现可折叠头部的也可横下滑动的列表的页面NestedScrollView中嵌套了ViewPager来展示不同的Tab滑动展示，ViewPager显示的高度为0，从AndroidStudio预览页面即可看到。 解决方案为NestedScrollView设置 android:fillViewport=”true” 解决1234567891011&lt;android.support.v4.widget.NestedScrollView android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:fillViewport=\"true\" app:layout_behavior=\"@string/appbar_scrolling_view_behavior\"&gt; &lt;android.support.v4.view.ViewPager android:id=\"@+id/viewpager\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" /&gt;&lt;/android.support.v4.widget.NestedScrollView&gt;","categories":[{"name":"错误志","slug":"错误志","permalink":"http://ncmon.com/categories/错误志/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://ncmon.com/tags/Android/"},{"name":"Design","slug":"Design","permalink":"http://ncmon.com/tags/Design/"},{"name":"error","slug":"error","permalink":"http://ncmon.com/tags/error/"}]},{"title":"Android Jetpack Architecture之ViewModel","slug":"Jetpack-Architecture-ViewModel","date":"2018-09-26T12:40:11.000Z","updated":"2018-10-27T06:02:35.102Z","comments":true,"path":"post/Jetpack-Architecture-ViewModel/","link":"http://ncmon.com/post/Jetpack-Architecture-ViewModel/","permalink":"http://ncmon.com/post/Jetpack-Architecture-ViewModel/","excerpt":"前言&ensp;&ensp;Jetpack已经出了很久很久了，近几年的GDD几乎每次都会介绍新的组件，说来惭愧，一直没有好好学习，看近年的Google 的很多Demo中其实都有所体现，之前都是大概的了解了一遍。最近决定，好好梳理一遍，既学习其用法，也尝试学习下其设计思想。也是时候该补充一下了。进入正题–ViewModel&ensp;&ensp;首先都是看官方的例子，ViewModel官方的的例子是会和另一个架构库LiveData写在一起，很多的博客也是照官方的例子来说明，开始接触时甚至给了我一种假象：ViewModel都是和LiveData一起使用的。后来阅读才了解，ViewModel和LiveData职责分工还是很明显的，使用LiveData Demo主要使用其observe功能，LiveDate的使用及原理之后再分析，甚至在appcompat-v7:27.1.1中直接单独集成了ViewModel.所以，故为排除干扰，今天不会使用官方的主流Demo用法，先来看ViewModel。","text":"前言&ensp;&ensp;Jetpack已经出了很久很久了，近几年的GDD几乎每次都会介绍新的组件，说来惭愧，一直没有好好学习，看近年的Google 的很多Demo中其实都有所体现，之前都是大概的了解了一遍。最近决定，好好梳理一遍，既学习其用法，也尝试学习下其设计思想。也是时候该补充一下了。进入正题–ViewModel&ensp;&ensp;首先都是看官方的例子，ViewModel官方的的例子是会和另一个架构库LiveData写在一起，很多的博客也是照官方的例子来说明，开始接触时甚至给了我一种假象：ViewModel都是和LiveData一起使用的。后来阅读才了解，ViewModel和LiveData职责分工还是很明显的，使用LiveData Demo主要使用其observe功能，LiveDate的使用及原理之后再分析，甚至在appcompat-v7:27.1.1中直接单独集成了ViewModel.所以，故为排除干扰，今天不会使用官方的主流Demo用法，先来看ViewModel。 ViewModel简介&ensp;&ensp;Android的UI控制器（Activity和Fragment）从创建到销毁拥有自己完整的生命周期，当系统配置发生改变时（(Configuration changes)），系统就会销毁Activity和与之关联的Fragment然后再次重建（可通过在AndroidManifast.xml中配置android:configChanges修改某些行为，这里不讨论）,那么存储在当前UI中的临时数据也会被清空，例如，登陆输入框，输入账号或密码后旋转屏幕，视图被重建，输入过的数据也清空了，这无疑是一种不友好的用户体验。对于少量的可序列化数据可以使用onSaveInstanceState()方法保存然后在onCreate()方法中重新恢复，正如所说onSaveInstanceState对于大量的数据缓存有一定的局限性，大量的数据缓存则可以使用Fragment.setRetainInstance(true)来保存数据。ViewModel也是提供了相同的功能，用来存储和管理与UI相关的数据，允许数据在系统配置变化后存活，我们一起看一下这个ViewModel的缓存是怎么实现的呢？ ViewModel使用方式先上效果图1234567891011121314public class MyViewModel extends ViewModel &#123; String name; public String getName()&#123; return name; &#125; public void setName(String name)&#123; this.name = name; &#125; @Override protected void onCleared() &#123; super.onCleared(); name = null; &#125; &#125; &nbsp;1234567891011121314151617181920212223242526272829303132public class ViewModelActivity extends AppCompatActivity implements View.OnClickListener &#123; private static final String TAG = \"ViewModelActivity\"; TextView textView; private MyViewModel myViewModel; @Override protected void onCreate(@Nullable Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_viewmodel); textView = findViewById(R.id.textView); textView.setOnClickListener(this); ViewModelProvider.Factory factory = ViewModelProvider.AndroidViewModelFactory.getInstance(getApplication()); /* *这里的this是ViewModelStoreOwner接口在appcompat-v7:27.1.1支持库中AppCompatActivity已经实现了， *如果是较低版本，需要更新支持包或者参考其实现对本来继承的Activity做对应实现。 */ ViewModelProvider provider = new ViewModelProvider(this, factory);// myViewModel = provider.get(MyViewModel.class); Log.e(TAG, \"onCreate: \" + myViewModel.getName() ); if (myViewModel.getName() != null) &#123; textView.setText(myViewModel.getName()); &#125; &#125; @Override public void onClick(View v) &#123; switch (v.getId())&#123; case R.id.textView: myViewModel.setName(\"MyViewModel Test\"); textView.setText(myViewModel.getName()); break; &#125; &#125;&#125; &nbsp;123456789101112131415161718192021222324&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;android.support.constraint.ConstraintLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:app=\"http://schemas.android.com/apk/res-auto\" xmlns:tools=\"http://schemas.android.com/tools\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\"&gt; &lt;TextView android:id=\"@+id/textView\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:layout_marginStart=\"8dp\" android:layout_marginTop=\"8dp\" android:layout_marginEnd=\"8dp\" android:layout_marginBottom=\"8dp\" android:text=\"default\" app:layout_constraintBottom_toBottomOf=\"parent\" app:layout_constraintEnd_toEndOf=\"parent\" app:layout_constraintStart_toStartOf=\"parent\" app:layout_constraintTop_toTopOf=\"parent\" /&gt;&lt;/android.support.constraint.ConstraintLayout&gt; 非常简单的一个例子，这就是ViewModel最简单的使用了，就是TextView中显示ViewModel的数据。ViewModel需要由ViewModelProvider.get(Class)来取得，旋转屏幕销毁后，之前改变的数据还在。接下来就是进入主题分析下ViewModel到底是怎么实现的呢？带着问题看源码： 带给我们的疑问 ViewModelProvider是干啥的？ AndroidViewModelFactory 这命名一看就是应该是工厂模式，工厂创建了什么？ provider.get(MyViewModel.class) 这里直接使用的get命名就得到了需要的唯一数据 注释中ViewModelStoreOwner又是什么角色？先看ViewModel类，没什么说的，就是一个么有任何真正实现的抽象类，只有一个抽象方法onCleared() 原理分析1234567891011public abstract class ViewModel &#123; /** * This method will be called when this ViewModel is no longer used and will be destroyed. * &lt;p&gt; * It is useful when ViewModel observes some data and you need to clear this subscription to * prevent a leak of this ViewModel. */ @SuppressWarnings(\"WeakerAccess\") protected void onCleared() &#123; &#125;&#125; 接着看下ViewModelFactory，顾名思义就是制造ViewModel的。AndroidViewModelFactory的继承关系如下: android.arch.lifecycle.ViewModelProvider.Factory android.arch.lifecycle.ViewModelProvider.NewInstanceFactory android.arch.lifecycle.ViewModelProvider.AndroidViewModelFactory Factory是一个只包含一个create的interface，NewInstanceFactory实现了该方法传入Class会利用ViewModel的默认无参构造器创建一个对应ViewModel的实例，而AndroidViewModelFactory增加了一个属性就是应用的Applicaion,同时重写create方法，查看ViewModel是否有包含Applicaion参数的构造方法从而使用，对应的其实还有一个AndroidViewModel是ViewModel的子类，默认已经实现了带有Application参数的构造方法，需要使用在ViewModel中使用application的直接继承AndroidViewModel就可以，看到这里其实最上面的例子有个不是问题的问题，其实上面的Factory直接使用NewInstanceFactory就可以创建出对应的ViewModel实例了。123456789101112131415/** * Implementations of &#123;@code Factory&#125; interface are responsible to instantiate ViewModels. */public interface Factory &#123; /** * Creates a new instance of the given &#123;@code Class&#125;. * &lt;p&gt; * * @param modelClass a &#123;@code Class&#125; whose instance is requested * @param &lt;T&gt; The type parameter for the ViewModel. * @return a newly created ViewModel */ @NonNull &lt;T extends ViewModel&gt; T create(@NonNull Class&lt;T&gt; modelClass);&#125; 12345678910111213141516171819/** * Simple factory, which calls empty constructor on the give class. */public static class NewInstanceFactory implements Factory &#123; @SuppressWarnings(\"ClassNewInstance\") @NonNull @Override public &lt;T extends ViewModel&gt; T create(@NonNull Class&lt;T&gt; modelClass) &#123; //noinspection TryWithIdenticalCatches try &#123; return modelClass.newInstance(); &#125; catch (InstantiationException e) &#123; throw new RuntimeException(\"Cannot create an instance of \" + modelClass, e); &#125; catch (IllegalAccessException e) &#123; throw new RuntimeException(\"Cannot create an instance of \" + modelClass, e); &#125; &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253/** * &#123;@link Factory&#125; which may create &#123;@link AndroidViewModel&#125; and * &#123;@link ViewModel&#125;, which have an empty constructor. */public static class AndroidViewModelFactory extends ViewModelProvider.NewInstanceFactory &#123; private static AndroidViewModelFactory sInstance; /** * Retrieve a singleton instance of AndroidViewModelFactory. * * @param application an application to pass in &#123;@link AndroidViewModel&#125; * @return A valid &#123;@link AndroidViewModelFactory&#125; */ @NonNull public static AndroidViewModelFactory getInstance(@NonNull Application application) &#123; if (sInstance == null) &#123; sInstance = new AndroidViewModelFactory(application); &#125; return sInstance; &#125; private Application mApplication; /** * Creates a &#123;@code AndroidViewModelFactory&#125; * * @param application an application to pass in &#123;@link AndroidViewModel&#125; */ public AndroidViewModelFactory(@NonNull Application application) &#123; mApplication = application; &#125; @NonNull @Override public &lt;T extends ViewModel&gt; T create(@NonNull Class&lt;T&gt; modelClass) &#123; if (AndroidViewModel.class.isAssignableFrom(modelClass)) &#123; //noinspection TryWithIdenticalCatches try &#123; return modelClass.getConstructor(Application.class).newInstance(mApplication); &#125; catch (NoSuchMethodException e) &#123; throw new RuntimeException(\"Cannot create an instance of \" + modelClass, e); &#125; catch (IllegalAccessException e) &#123; throw new RuntimeException(\"Cannot create an instance of \" + modelClass, e); &#125; catch (InstantiationException e) &#123; throw new RuntimeException(\"Cannot create an instance of \" + modelClass, e); &#125; catch (InvocationTargetException e) &#123; throw new RuntimeException(\"Cannot create an instance of \" + modelClass, e); &#125; &#125; return super.create(modelClass); &#125;&#125; 之后通过ViewModelStoreOwner和刚刚创建的Factory创建出ViewModelPrivider实例12345678910111213141516171819202122232425/** * Creates &#123;@code ViewModelProvider&#125;, which will create &#123;@code ViewModels&#125; via the given * &#123;@code Factory&#125; and retain them in a store of the given &#123;@code ViewModelStoreOwner&#125;. * * @param owner a &#123;@code ViewModelStoreOwner&#125; whose &#123;@link ViewModelStore&#125; will be used to * retain &#123;@code ViewModels&#125; * @param factory a &#123;@code Factory&#125; which will be used to instantiate * new &#123;@code ViewModels&#125; */public ViewModelProvider(@NonNull ViewModelStoreOwner owner, @NonNull Factory factory) &#123; this(owner.getViewModelStore(), factory);&#125;/** * Creates &#123;@code ViewModelProvider&#125;, which will create &#123;@code ViewModels&#125; via the given * &#123;@code Factory&#125; and retain them in the given &#123;@code store&#125;. * * @param store &#123;@code ViewModelStore&#125; where ViewModels will be stored. * @param factory factory a &#123;@code Factory&#125; which will be used to instantiate * new &#123;@code ViewModels&#125; */public ViewModelProvider(@NonNull ViewModelStore store, @NonNull Factory factory) &#123; mFactory = factory; this.mViewModelStore = store;&#125; 1234567891011121314151617/** * A scope that owns &#123;@link ViewModelStore&#125;. * &lt;p&gt; * A responsibility of an implementation of this interface is to retain owned ViewModelStore * during the configuration changes and call &#123;@link ViewModelStore#clear()&#125;, when this scope is * going to be destroyed. */@SuppressWarnings(\"WeakerAccess\")public interface ViewModelStoreOwner &#123; /** * Returns owned &#123;@link ViewModelStore&#125; * * @return a &#123;@code ViewModelStore&#125; */ @NonNull ViewModelStore getViewModelStore();&#125; ViewModelStoreOwner 也是一个接口是FragmentActivity实现了该接口并实现了其中的getViewModelStore()方法1234567891011121314151617181920212223242526272829303132public class FragmentActivity extends BaseFragmentActivityApi16 implements ViewModelStoreOwner...&#123; private ViewModelStore mViewModelStore; @Override protected void onCreate(@Nullable Bundle savedInstanceState) &#123; mFragments.attachHost(null /*parent*/); super.onCreate(savedInstanceState); NonConfigurationInstances nc = (NonConfigurationInstances) getLastNonConfigurationInstance(); if (nc != null) &#123; mViewModelStore = nc.viewModelStore; &#125; /** * Returns the &#123;@link ViewModelStore&#125; associated with this activity * * @return a &#123;@code ViewModelStore&#125; */ @NonNull @Override public ViewModelStore getViewModelStore() &#123; if (getApplication() == null) &#123; throw new IllegalStateException(\"Your activity is not yet attached to the \" + \"Application instance. You can't request ViewModel before onCreate call.\"); &#125; if (mViewModelStore == null) &#123; mViewModelStore = new ViewModelStore(); &#125; return mViewModelStore; &#125;&#125; 这个ViewModelStore又是什么呢，其实就是真正利用HashMap存储ViewModel的地方了，看下代码在存储和clear同时会调用ViewModel需要实现的抽象方法onClear()12345678910111213141516171819202122232425public class ViewModelStore &#123; private final HashMap&lt;String, ViewModel&gt; mMap = new HashMap&lt;&gt;(); final void put(String key, ViewModel viewModel) &#123; ViewModel oldViewModel = mMap.put(key, viewModel); if (oldViewModel != null) &#123; oldViewModel.onCleared(); &#125; &#125; final ViewModel get(String key) &#123; return mMap.get(key); &#125; /** * Clears internal storage and notifies ViewModels that they are no longer used. */ public final void clear() &#123; for (ViewModel vm : mMap.values()) &#123; vm.onCleared(); &#125; mMap.clear(); &#125;&#125; 这样ViewModelProvider就是有了一个ViewModel的容器，这时去调用ViewModelProvider的get(Class)方法就是去调用mViewModelStore的get()方法取出对应的ViewModel所以这里只要持有的ViewModelStore是有缓存的，那么取出的ViewModel就是相同的缓存了。12345678910111213141516171819202122232425262728293031323334353637383940414243/** * Returns an existing ViewModel or creates a new one in the scope (usually, a fragment or * an activity), associated with this &#123;@code ViewModelProvider&#125;. * &lt;p&gt; * The created ViewModel is associated with the given scope and will be retained * as long as the scope is alive (e.g. if it is an activity, until it is * finished or process is killed). * * @param modelClass The class of the ViewModel to create an instance of it if it is not * present. * @param &lt;T&gt; The type parameter for the ViewModel. * @return A ViewModel that is an instance of the given type &#123;@code T&#125;. */@NonNull@MainThreadpublic &lt;T extends ViewModel&gt; T get(@NonNull Class&lt;T&gt; modelClass) &#123; String canonicalName = modelClass.getCanonicalName(); if (canonicalName == null) &#123; throw new IllegalArgumentException(\"Local and anonymous classes can not be ViewModels\"); &#125; return get(DEFAULT_KEY + \":\" + canonicalName, modelClass);&#125;@NonNull@MainThreadpublic &lt;T extends ViewModel&gt; T get(@NonNull String key, @NonNull Class&lt;T&gt; modelClass) &#123; ViewModel viewModel = mViewModelStore.get(key); if (modelClass.isInstance(viewModel)) &#123; //noinspection unchecked return (T) viewModel; &#125; else &#123; //noinspection StatementWithEmptyBody if (viewModel != null) &#123; // TODO: log a warning. &#125; &#125; viewModel = mFactory.create(modelClass); mViewModelStore.put(key, viewModel); //noinspection unchecked return (T) viewModel;&#125; 看到这里就会发现ViewModelStore的缓存其实是通过NonConfigurationInstances的缓存来实现的，这样就完成了Activity销毁重建后ViewModel还保存原来的数据的过程，那么NonConfigurationInstances 是什么呢？如果有了解过使用在Activity中使用onRetainNonConfigurationInstance()保存缓存数据，在onCreate()中通过getLastNonConfigurationInstance()恢复之前的数据状态的同学可能会很熟悉这里的写法，是的，这里FragmentActivity就是使用的这种方式来保存之前的ViewModelStore,看下FragmentActivity的onRetainNonConfigurationInstance()方法。 12345678910111213141516171819202122232425/** * Retain all appropriate fragment state. You can NOT * override this yourself! Use &#123;@link #onRetainCustomNonConfigurationInstance()&#125; * if you want to retain your own state. */@Overridepublic final Object onRetainNonConfigurationInstance() &#123; if (mStopped) &#123; doReallyStop(true); &#125; Object custom = onRetainCustomNonConfigurationInstance(); FragmentManagerNonConfig fragments = mFragments.retainNestedNonConfig(); if (fragments == null &amp;&amp; mViewModelStore == null &amp;&amp; custom == null) &#123; return null; &#125; NonConfigurationInstances nci = new NonConfigurationInstances(); nci.custom = custom; nci.viewModelStore = mViewModelStore;//就是这里了，会把之前的VeiwmodelStroe存储到NonConfigurationInstances中以供后续恢复使用 nci.fragments = fragments; return nci;&#125; 这里其实再次出现了一个问题 onRetainNonConfigurationInstance()和getLastNonConfigurationInstance()又是怎么恢复数据呢?…这个其实和Activity的启动流程相关，这里也介绍一下吧，之后的内容其实是Activity的内容了，趁这次看ViwModel也跟着看了一遍，有了解过Activity启动流程的同学更容易理解的多，大家酌情观看。 也不能从头开始说起，再从头就要越扯越远了，就从ActivityThread.java中的scheduleLaunchActivity开始1234567891011121314151617181920212223242526272829303132333435@Overridepublic final void scheduleLaunchActivity(Intent intent, IBinder token, int ident, ActivityInfo info, Configuration curConfig, Configuration overrideConfig, CompatibilityInfo compatInfo, String referrer, IVoiceInteractor voiceInteractor, int procState, Bundle state, PersistableBundle persistentState, List&lt;ResultInfo&gt; pendingResults, List&lt;ReferrerIntent&gt; pendingNewIntents, boolean notResumed, boolean isForward, ProfilerInfo profilerInfo) &#123; updateProcessState(procState, false); ActivityClientRecord r = new ActivityClientRecord(); r.token = token; r.ident = ident; r.intent = intent; r.referrer = referrer; r.voiceInteractor = voiceInteractor; r.activityInfo = info; r.compatInfo = compatInfo; r.state = state; r.persistentState = persistentState; r.pendingResults = pendingResults; r.pendingIntents = pendingNewIntents; r.startsNotResumed = notResumed; r.isForward = isForward; r.profilerInfo = profilerInfo; r.overrideConfig = overrideConfig; updatePendingConfiguration(curConfig); sendMessage(H.LAUNCH_ACTIVITY, r);&#125; 从ActivityThread.java中H（extents Handler）接收到LAUNCH_ACTIVITY，并且会接收ActivityClientRecord，其中会调用ActivityThread的handleLaunchActivity方法：1234567891011121314//ActivityThread.java//没有前后文的H中的handleMessage~~~ public void handleMessage(Message msg) &#123; if (DEBUG_MESSAGES) Slog.v(TAG, \"&gt;&gt;&gt; handling: \" + codeToString(msg.what)); switch (msg.what) &#123; case LAUNCH_ACTIVITY: &#123; Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, \"activityStart\"); final ActivityClientRecord r = (ActivityClientRecord) msg.obj; //ActivityClientRecord 是apk进程中一个Activity的代表，这个对象的activity成员引用真正的Activity组件,后面的都和它有关系 r.packageInfo = getPackageInfoNoCheck( r.activityInfo.applicationInfo, r.compatInfo); handleLaunchActivity(r, null, \"LAUNCH_ACTIVITY\");///这里~这里~ Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER); &#125; break; 1234567891011121314151617181920212223242526272829private void handleLaunchActivity(ActivityClientRecord r, Intent customIntent, String reason) &#123; ... Activity a = performLaunchActivity(r, customIntent); ...&#125;private Activity performLaunchActivity(ActivityClientRecord r, Intent customIntent) &#123;... if (activity != null) &#123; CharSequence title = r.activityInfo.loadLabel(appContext.getPackageManager()); Configuration config = new Configuration(mCompatConfiguration); if (r.overrideConfig != null) &#123; config.updateFrom(r.overrideConfig); &#125; if (DEBUG_CONFIGURATION) Slog.v(TAG, \"Launching activity \" + r.activityInfo.name + \" with config \" + config); Window window = null; if (r.mPendingRemoveWindow != null &amp;&amp; r.mPreserveWindow) &#123; window = r.mPendingRemoveWindow; r.mPendingRemoveWindow = null; r.mPendingRemoveWindowManager = null; &#125; appContext.setOuterContext(activity); activity.attach(appContext, this, getInstrumentation(), r.token, r.ident, app, r.intent, r.activityInfo, title, r.parent, r.embeddedID, r.lastNonConfigurationInstances, config, //看到这个r.lastNonConfigurationInstances 就是在Activity方法中调用getLastNonConfigurationInstance()获取到的Object了。 r.referrer, r.voiceInteractor, window, r.configCallback);...&#125; 注释中的地方就是lastNonConfigurationInstances的赋值的地方，可能会发现在scheduleLaunchActivity并没有对lastNonConfigurationInstances赋值，因为第一次启动Activity时，这里其实就是null的，那么赋值的地方在哪里呢，既然是销毁后会恢复数据，追踪发现在performDestroyActivity()也就是在调用onDestroy生命周期之前有这样一段代码1234567891011121314151617181920212223private ActivityClientRecord performDestroyActivity(IBinder token, boolean finishing, int configChanges, boolean getNonConfigInstance) &#123; ActivityClientRecord r = mActivities.get(token); ...无关代码省略 if (getNonConfigInstance) &#123; try &#123; r.lastNonConfigurationInstances = r.activity.retainNonConfigurationInstances();///就是这里出现了想要找的NonConfigurationInstances &#125; catch (Exception e) &#123; if (!mInstrumentation.onException(r.activity, e)) &#123; throw new RuntimeException( \"Unable to retain activity \" + r.intent.getComponent().toShortString() + \": \" + e.toString(), e); &#125; &#125; &#125; try &#123; r.activity.mCalled = false; mInstrumentation.callActivityOnDestroy(r.activity); ...无关代码省略 return r; &#125; 在performDestroyActivity()调用了Activity.retainNonConfigurationInstances()方法了，所以逻辑切换回Activity中…1234567891011121314151617181920212223242526272829303132333435363738394041 /** * This method is similar to &#123;@link #onRetainNonConfigurationInstance()&#125; except that * it should return either a mapping from child activity id strings to arbitrary objects, * or null. This method is intended to be used by Activity framework subclasses that control a * set of child activities, such as ActivityGroup. The same guarantees and restrictions apply * as for &#123;@link #onRetainNonConfigurationInstance()&#125;. The default implementation returns null. */@NullableHashMap&lt;String,Object&gt; onRetainNonConfigurationChildInstances() &#123; return null;&#125;NonConfigurationInstances retainNonConfigurationInstances() &#123; Object activity = onRetainNonConfigurationInstance();///熟悉的代码，原来的配方，和分析ActivityThread之前联系起来了，在Activity中是空实现，这里就是获取子类的NonConfigurationInstance()，之前的例子就是的得FragmentActivity中的具体实现，上文中已经在分析ActivityThread.java已经指出。 HashMap&lt;String, Object&gt; children = onRetainNonConfigurationChildInstances(); FragmentManagerNonConfig fragments = mFragments.retainNestedNonConfig(); // We're already stopped but we've been asked to retain. // Our fragments are taken care of but we need to mark the loaders for retention. // In order to do this correctly we need to restart the loaders first before // handing them off to the next activity. mFragments.doLoaderStart(); mFragments.doLoaderStop(true); ArrayMap&lt;String, LoaderManager&gt; loaders = mFragments.retainLoaderNonConfig(); if (activity == null &amp;&amp; children == null &amp;&amp; fragments == null &amp;&amp; loaders == null &amp;&amp; mVoiceInteractor == null) &#123; return null; &#125; NonConfigurationInstances nci = new NonConfigurationInstances(); nci.activity = activity; nci.children = children; nci.fragments = fragments; nci.loaders = loaders; if (mVoiceInteractor != null) &#123; mVoiceInteractor.retainInstance(); nci.voiceInteractor = mVoiceInteractor; &#125; return nci;//这里返回的是Activity中的NonConfigurationInstances就保存在了ActivityClientRecord中了&#125; 至此，ActivityClientRecord就不再深入了，可以看到在Activity中是以一个ArrayMap来保存Activity的记录，记录的就是Activity的状态，所以这里就实现了对NonConfigurationInstances的保存。 结语：至此就基本看完了ViewModel在Activity中的使用和原理，在Fragment中的实现主要是使用setRetainInstance(true)的方式去保存，跟今天的分析也有关联，分析源码的过程总是看着就有新的问题，再次带着问题去解决会再次有不同的收获，本文的理解也可能有偏差，如有错误和想要交流的也欢迎指正沟通。","categories":[{"name":"技术栈","slug":"技术栈","permalink":"http://ncmon.com/categories/技术栈/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://ncmon.com/tags/Android/"},{"name":"Jetpack","slug":"Jetpack","permalink":"http://ncmon.com/tags/Jetpack/"}]},{"title":"Ubuntu搭建Nginx图片服务器","slug":"build-an-image-server","date":"2018-01-11T12:40:11.000Z","updated":"2018-10-26T14:54:02.067Z","comments":true,"path":"post/build-an-image-server/","link":"http://ncmon.com/post/build-an-image-server/","permalink":"http://ncmon.com/post/build-an-image-server/","excerpt":"也许算作是建站以来的第一篇真正意义上的总结博客。 首先感谢开源本主题的viosey同学和辛苦维护本主题的neoFelhz同学，对此主题极为喜欢。 新发现了当前的这个Meterial主题后发现居然有一个Gallery模板可以展示照片，平时的博客使用图片需要存放在一个位置上，平时也有一些业余的摄影爱好需要刚好可以存放，当然可以使用如之前使用过的七牛云等云对象存储平台存储使用，我这里也是刚好有个云服务器可以做存储就想着自己搭建一个图片服务器方便管理，也刚好能学习一下服务器方面的一些知识，经多次尝试，故总结一下,话不多说，开始行动.","text":"也许算作是建站以来的第一篇真正意义上的总结博客。 首先感谢开源本主题的viosey同学和辛苦维护本主题的neoFelhz同学，对此主题极为喜欢。 新发现了当前的这个Meterial主题后发现居然有一个Gallery模板可以展示照片，平时的博客使用图片需要存放在一个位置上，平时也有一些业余的摄影爱好需要刚好可以存放，当然可以使用如之前使用过的七牛云等云对象存储平台存储使用，我这里也是刚好有个云服务器可以做存储就想着自己搭建一个图片服务器方便管理，也刚好能学习一下服务器方面的一些知识，经多次尝试，故总结一下,话不多说，开始行动. 环境准备Ubuntu版本Ubuntu 16.04.3 安装Nginx首先是准备编译Nginx的前期准备工作 先更新一下源&gt; apt-get update 安装gcc g++依赖库&gt; apt-get install build-essential &gt; apt-get install libtool 安装prce依赖库&gt; apt-get install libpcre3 libpcre3-dev 安装 zlib依赖库&gt; apt-get install zlib1g-dev 安装 ssl依赖库&gt; apt-get install openssl 编译Nginx下载Nginx有对应的版本，我这里下载是当前的最新版本1.13.8 &gt; #解压下载下来的压缩包 &gt; tar -zxvf nginx-1.13.8.tar.gz &gt; #进入解压目录 &gt; cd nginx-1.13.8 &gt; #配置并生成makefile &gt; ./configure --prefix=/usr/local/nginx &gt; #编译 &gt; make &gt; #安装 &gt; make install &gt; #启动Nginx &gt; /usr/local/nginx/sbin/nginx -c /usr/local/nginx/conf/nginx.conf 此时Nginx就安装完成了，会使用默认的80端口启动，如果有启动apache2服务的这里会用冲突，这里不是重点，可查询解决，启动完成可直接通过服务器ip或者云解析的域名查看默认网页 默认的网页长这个样子 安装与配置vsftpd安装vsftpd&gt; apt-get install vsftpd 启动vsftpd服务&gt;service vsftpd start 新建ftpuser目录作为ftp主目录 （ftpuser为目录名，随个人喜好创建）&gt;mkdir /home/ftpuser 新建ftpuser用户指定用户主目录和设置用户密码 （ftpuser为用户名，随个人喜好创建）&gt;useradd -d /home/ftpuser -s /bin/bash ftpuser &gt;passwd ftpuser 制定用户组&gt;chown ftpuser:ftpuser /home/ftpuser 新建文件/etc/vsftpd.user_list，用于存放允许访问ftp的用户&gt;vim /etc/vsftpd.user_list 编辑vsftpd配置文件&gt;vim /etc/vsftpd.conf 做如下修改： 打开注释 write_enable=YES 添加信息 userlist_file=/etc/vsftpd.user_list 添加信息 userlist_enable=YES 添加信息 userlist_deny=NO 修改完成后保存退出。 重启vsftpd服务&gt;service vsftpd restart 这是可以使用filezilla等ftp软件使用刚刚新建的用户名和密码访问测试是否成功 OK，准备工作完成开始上传图片，开始正式图片服务器工作 创建存储图片的根目录 （在ftpuser目录下,我这里使用www/images）&gt;cd /home/ftpuser &gt;mkdir -p www/images 在nginx目录下创建images目录&gt;mkdir /usr/local/nginx/html/images 修改nginx/conf/nginx.conf在默认的server里再添加一个location并指定实际路径:location /images/ { root /home/ftpuser/www/; autoindex on; } 修改用户访问权限&gt;chmod 755 /home/ftpuser/www/images 使用filezilla 等ftp工具使用ftpuser用户登录即可上传图片 测试送上一张最近的长安街慢门效果照片★,°:.☆(￣▽￣)/$:.°★。大功告成！ 撒花！","categories":[{"name":"技术栈","slug":"技术栈","permalink":"http://ncmon.com/categories/技术栈/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://ncmon.com/tags/Linux/"},{"name":"Ubuntu","slug":"Ubuntu","permalink":"http://ncmon.com/tags/Ubuntu/"},{"name":"FTP","slug":"FTP","permalink":"http://ncmon.com/tags/FTP/"}]},{"title":"Android Studio import project 出现Error错误 程序包org.apache.http不存在","slug":"Android-Studio-Error-2","date":"2018-01-07T15:01:52.000Z","updated":"2018-11-18T16:09:19.530Z","comments":true,"path":"post/Android-Studio-Error-2/","link":"http://ncmon.com/post/Android-Studio-Error-2/","permalink":"http://ncmon.com/post/Android-Studio-Error-2/","excerpt":"","text":"问题描述遇到新的产品形态、样式需求我们经常会在Github搜索开源项目，有些项目是早期Android版本中开发而成，后续Google会有部分API在新版本中的SDK放弃集成，这次我导入一个项目时就遇到这样一个错误 解决办法如果经历过Android 4.4 时期的同学应该会觉得org.apache.http这个包很熟悉，这里显示错误是因为在targetsdk：23以上版本SDK中已经不再集成此包，如需使用可添加useLibrary “org.apache.http.legacy”依赖即可 。 1234567apply plugin: 'com.android.application'android &#123; compileSdkVersion 23 buildToolsVersion \"23.0.3\" useLibrary \"org.apache.http.legacy\" ...&#125;","categories":[{"name":"错误志","slug":"错误志","permalink":"http://ncmon.com/categories/错误志/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://ncmon.com/tags/Android/"},{"name":"IDEError","slug":"IDEError","permalink":"http://ncmon.com/tags/IDEError/"}]},{"title":"RecyclerView排雷--notifyItemRemoved下标（position）不能更新","slug":"RecyclerView-clear-of-mines-1","date":"2017-10-29T15:48:52.000Z","updated":"2018-11-09T00:43:47.005Z","comments":true,"path":"post/RecyclerView-clear-of-mines-1/","link":"http://ncmon.com/post/RecyclerView-clear-of-mines-1/","permalink":"http://ncmon.com/post/RecyclerView-clear-of-mines-1/","excerpt":"","text":"问题描述用以显示列表类型的UI我们经常使用ListView，GridView，Google推出RecyclerView之后，大部分的使用均转换到了RecyclerView中，可定制化十分强，但是使用过程中难免碰到一些问题，以前使用ListView多是使用notifyDataSetChanged（）更新数据，使用RecyclerView删除时，为了使用其自身的删除过渡动画使用notifyItemRemoved删除，那么就碰到了一个问题，再onBindViewHolder中设置了setTag（position）123456@Overridepublic void onBindViewHolder(RecyclerView.ViewHolder holder,int position)&#123; ... holder.itemView.setTag(position) ...&#125; 直接使用notifyItemRemoved(posiaon)删除会导致该下标不能更新就导致一系列的Bug（/衰） 解决方案查询到了解决办法特此记录一下:为了修复该问题删除之后需要调用notifyItenRangeChanged方法，使下面的itemview重新onBind:1234567public void deleteItem(int position)&#123; mDataList.remove(position); notifyItemRemoved(position); if(position != mDataList.size())&#123; // 如果移除的是最后一个，忽略 notifyItemRangeChanged(position, mDataList.size() - position); &#125;&#125; 如果不需要使用动画或更改自定义的动画效果可以添加一下代码1mRecyclerView.setItemAnimator(newDefaultItemAnimator());","categories":[{"name":"技术栈","slug":"技术栈","permalink":"http://ncmon.com/categories/技术栈/"}],"tags":[]},{"title":"Android Studio 更新后出现Error:No service of type Factory  available in ProjectScopeServices.解决办法","slug":"Android-Studio-Error-1","date":"2017-03-15T17:01:52.000Z","updated":"2018-11-18T16:09:20.539Z","comments":true,"path":"post/Android-Studio-Error-1/","link":"http://ncmon.com/post/Android-Studio-Error-1/","permalink":"http://ncmon.com/post/Android-Studio-Error-1/","excerpt":"","text":"问题描述今天更新Android Studio后 之前能运行的项目出现错误: 解决办法查找到解决方案在此记录一下：是github的 自动化打包插件maven 版本需要更新导致","categories":[{"name":"错误志","slug":"错误志","permalink":"http://ncmon.com/categories/错误志/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://ncmon.com/tags/Android/"},{"name":"IDEError","slug":"IDEError","permalink":"http://ncmon.com/tags/IDEError/"}]}]}